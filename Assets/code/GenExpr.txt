// =============================================================================
// PARAMETROS PRINCIPALES DE CONTROL
// =============================================================================
Param a_FREQ1(0, min=20, default=250, max=1000);
Param b_FREQ2(0, min=1000, default=5000, max=20000);

Param c_LOW(1, min=0, default=1, max=2);
Param d_MED(1, min=0, default=1, max=2);
Param e_HIGH(1, min=0, default=1, max=2);

Param f_SOLOLOW(0, min=0, default=0, max=1);
Param g_SOLOMED(0, min=0, default=0, max=1);
Param h_SOLOHIGH(0, min=0, default=0, max=1);

Param i_BYPASS(0, min=0, default=0, max=1);
Param j_input(0, min=0, default=1, max=1);

Param k_LOW_bal(0, max=1, default=0.5, min=0);
Param l_MED_bal(0, min=0, default=0.5, max=1);
Param m_HIGH_bal(0, min=0, default=0.5, max=1);

Param x_DRYWET(0, min=0, default=1, max=1);
Param n_MUTLOW(0, min=0, default=0, max=1);
Param o_MUTMED(0, min=0, default=0, max=1);
Param p_MUTHIGH(0, min=0, default=0, max=1);

Param v_TRIM(0, min=-12, default=0, max=12); // implementar
Param w_MAKEUP(0, min=-12, default=0, max=12);

// =============================================================================
// HISTORIALES (ESTADOS DEL PROCESADOR)
// =============================================================================
History wetRightLowStage1X1(0);
History wetRightLowStage1X2(0);
History wetRightLowStage1Y1(0);
History wetRightLowStage1Y2(0);
History wetRightLowStage2X1(0);
History wetRightLowStage2X2(0);
History wetRightLowStage2Y1(0);
History wetRightLowStage2Y2(0);
History wetRightHighStage1X1(0);
History wetRightHighStage1X2(0);
History wetRightHighStage1Y1(0);
History wetRightHighStage1Y2(0);
History wetRightHighStage2X1(0);
History wetRightHighStage2X2(0);
History wetRightHighStage2Y1(0);
History wetRightHighStage2Y2(0);
History wetRightMidStage1X1(0);
History wetRightMidStage1X2(0);
History wetRightMidStage1Y1(0);
History wetRightMidStage1Y2(0);
History wetRightMidStage2X1(0);
History wetRightMidStage2X2(0);
History wetRightMidStage2Y1(0);
History wetRightMidStage2Y2(0);
History wetRightHighBandStage1X1(0);
History wetRightHighBandStage1X2(0);
History wetRightHighBandStage1Y1(0);
History wetRightHighBandStage1Y2(0);
History wetRightHighBandStage2X1(0);
History wetRightHighBandStage2X2(0);
History wetRightHighBandStage2Y1(0);
History wetRightHighBandStage2Y2(0);

History dryWetHistory(0);
History bypassHistory(0);
History soloMidHistory(0);
History soloHighHistory(0);
History soloLowHistory(0);
History inputModeHistory(0);
History lowBandGainHistory(0);
History midBandGainHistory(0);
History midBalanceHistory(0);
History highBandGainHistory(0);
History highBalanceHistory(0);
History highCrossoverHistory(0);
History lowCrossoverHistory(0);

History dryLeftLowLpStage1X1(0);
History dryLeftLowLpStage1X2(0);
History dryLeftLowLpStage1Y1(0);
History dryLeftLowLpStage1Y2(0);
History dryLeftLowLpStage2X1(0);
History dryLeftLowLpStage2X2(0);
History dryLeftLowLpStage2Y1(0);
History dryLeftLowLpStage2Y2(0);
History dryLeftLowHpStage1X1(0);
History dryLeftLowHpStage1X2(0);
History dryLeftLowHpStage1Y1(0);
History dryLeftLowHpStage1Y2(0);
History dryLeftLowHpStage2X1(0);
History dryLeftLowHpStage2X2(0);
History dryLeftLowHpStage2Y1(0);
History dryLeftLowHpStage2Y2(0);
History dryLeftMidLpStage1X1(0);
History dryLeftMidLpStage1X2(0);
History dryLeftMidLpStage1Y1(0);
History dryLeftMidLpStage1Y2(0);
History dryLeftMidLpStage2X1(0);
History dryLeftMidLpStage2X2(0);
History dryLeftMidLpStage2Y1(0);
History dryLeftMidLpStage2Y2(0);
History dryLeftHighHpStage1X1(0);
History dryLeftHighHpStage1X2(0);
History dryLeftHighHpStage1Y1(0);
History dryLeftHighHpStage1Y2(0);
History dryLeftHighHpStage2X1(0);
History dryLeftHighHpStage2X2(0);
History dryLeftHighHpStage2Y1(0);
History dryLeftHighHpStage2Y2(0);

History apLeftLowLpStage1X1(0);
History apLeftLowLpStage1X2(0);
History apLeftLowLpStage1Y1(0);
History apLeftLowLpStage1Y2(0);
History apLeftLowLpStage2X1(0);
History apLeftLowLpStage2X2(0);
History apLeftLowLpStage2Y1(0);
History apLeftLowLpStage2Y2(0);
History apLeftLowHpStage1X1(0);
History apLeftLowHpStage1X2(0);
History apLeftLowHpStage1Y1(0);
History apLeftLowHpStage1Y2(0);
History apLeftLowHpStage2X1(0);
History apLeftLowHpStage2X2(0);
History apLeftLowHpStage2Y1(0);
History apLeftLowHpStage2Y2(0);
History dryRightLowLpStage1X1(0);
History dryRightLowLpStage1X2(0);
History dryRightLowLpStage1Y1(0);
History dryRightLowLpStage1Y2(0);
History dryRightLowLpStage2X1(0);
History dryRightLowLpStage2X2(0);
History dryRightLowLpStage2Y1(0);
History dryRightLowLpStage2Y2(0);
History dryRightLowHpStage1X1(0);
History dryRightLowHpStage1X2(0);
History dryRightLowHpStage1Y1(0);
History dryRightLowHpStage1Y2(0);
History dryRightLowHpStage2X1(0);
History dryRightLowHpStage2X2(0);
History dryRightLowHpStage2Y1(0);
History dryRightLowHpStage2Y2(0);
History dryRightMidLpStage1X1(0);
History dryRightMidLpStage1X2(0);
History dryRightMidLpStage1Y1(0);
History dryRightMidLpStage1Y2(0);
History dryRightMidLpStage2X1(0);
History dryRightMidLpStage2X2(0);
History dryRightMidLpStage2Y1(0);
History dryRightMidLpStage2Y2(0);
History dryRightHighHpStage1X1(0);
History dryRightHighHpStage1X2(0);
History dryRightHighHpStage1Y1(0);
History dryRightHighHpStage1Y2(0);
History dryRightHighHpStage2X1(0);
History dryRightHighHpStage2X2(0);
History dryRightHighHpStage2Y1(0);
History dryRightHighHpStage2Y2(0);
History apRightLowLpStage1X1(0);
History apRightLowLpStage1X2(0);
History apRightLowLpStage1Y1(0);
History apRightLowLpStage1Y2(0);
History apRightLowLpStage2X1(0);
History apRightLowLpStage2X2(0);
History apRightLowLpStage2Y1(0);
History apRightLowLpStage2Y2(0);
History apRightLowHpStage1X1(0);
History apRightLowHpStage1X2(0);
History apRightLowHpStage1Y1(0);
History apRightLowHpStage1Y2(0);
History apRightLowHpStage2X1(0);
History apRightLowHpStage2X2(0);
History apRightLowHpStage2Y1(0);
History apRightLowHpStage2Y2(0);
History lowBypassHistory(0);
History lowBalanceHistory(0);
History lowWidthHistory(0);
History lowInputModeHistory(0);
History midBypassHistory(0);
History midMakeupHistory(0);
History midBalanceInternalHistory(0);
History midWidthHistory(0);
History midInputModeHistory(0);
History midBandGainHistoryInternal(0);
History midSideGainHistory(0);
History midInvertHistory(0);
History highBypassHistory(0);
History highMakeupHistory(0);
History highBalanceHistoryInternal(0);
History highWidthHistory(0);
History highInputModeHistory(0);
History highBandGainHistoryInternal(0);
History highSideGainHistory(0);

//  smoothing histories for band mutes
History muteLowHistory(0);
History muteMidHistory(0);
History muteHighHistory(0);

//  Energías RMS y correlación por banda para la normalización de anchura
History lowEnergyM2(1e-12);
History lowSideEnergyM2(1e-12);
History lowCrossCorrelationM2(0); //  Correlación cruzada (LR) LOW

//  Energías por canal para normalización sensible a la correlación
History lowLeftEnergyM2(1e-12);   // <L^2> LOW
History lowRightEnergyM2(1e-12);   // <R^2> LOW
History midLeftEnergyM2(1e-12);   // <L^2> MID
History midRightEnergyM2(1e-12);   // <R^2> MID
History highLeftEnergyM2(1e-12);  // <L^2> HIGH
History highRightEnergyM2(1e-12);  // <R^2> HIGH
History midEnergyM2(1e-12);
History midSideEnergyM2(1e-12);
History midCrossCorrelationM2(0); //  Correlación cruzada (LR) MID
History highEnergyM2(1e-12);
History highSideEnergyM2(1e-12);
History highCrossCorrelationM2(0); //  Correlación cruzada (LR) HIGH
History highInvertHistory(0);
History wetLeftLowStage1X1(0);
History wetLeftLowStage1X2(0);
History wetLeftLowStage1Y1(0);
History wetLeftLowStage1Y2(0);
History wetLeftLowStage2X1(0);
History wetLeftLowStage2X2(0);
History wetLeftLowStage2Y1(0);
History wetLeftLowStage2Y2(0);
History wetLeftHighStage1X1(0);
History wetLeftHighStage1X2(0);
History wetLeftHighStage1Y1(0);
History wetLeftHighStage1Y2(0);
History wetLeftHighStage2X1(0);
History wetLeftHighStage2X2(0);
History wetLeftHighStage2Y1(0);
History wetLeftHighStage2Y2(0);
History wetLeftMidStage1X1(0);
History wetLeftMidStage1X2(0);
History wetLeftMidStage1Y1(0);
History wetLeftMidStage1Y2(0);
History wetLeftMidStage2X1(0);
History wetLeftMidStage2X2(0);
History wetLeftMidStage2Y1(0);
History wetLeftMidStage2Y2(0);
History wetLeftHighBandStage1X1(0);
History wetLeftHighBandStage1X2(0);
History wetLeftHighBandStage1Y1(0);
History wetLeftHighBandStage1Y2(0);
History wetLeftHighBandStage2X1(0);
History wetLeftHighBandStage2X2(0);
History wetLeftHighBandStage2Y1(0);
History wetLeftHighBandStage2Y2(0);

// -----------------------------------------------------------------------------
// HISTORIALES DE TRIM (SMOOTHING)
// -----------------------------------------------------------------------------
History trimLeftHistory(1); // smoother L (1 = 0 dB)
History trimRightHistory(1); // smoother R

// -----------------------------------------------------------------------------
// HISTORIALES DE MAKEUP (SMOOTHING)
// -----------------------------------------------------------------------------
History makeupLeftHistory(1); // smoother L (arranca en 0 dB = 1)
History makeupRightHistory(1); // smoother R
History trimSharedHistory(1);
History makeupSharedHistory(1);

// =============================================================================
// CONSTANTES MATEMATICAS COMPARTIDAS
// =============================================================================
// Agrupa constantes reutilizables para todas las bandas
piConstant      = pi;
sqrtTwoConstant = sqrt(2);
epsilonConstant = 1e-12;
slewDefault     = 0.999;

// =============================================================================
// ALIAS DE PARAMETROS EN camelCase
// =============================================================================
freqLowHz    = a_FREQ1;
freqHighHz   = b_FREQ2;

bandLowGain  = c_LOW;
bandMidGain  = d_MED;
bandHighGain = e_HIGH;

soloLow      = f_SOLOLOW;
soloMid      = g_SOLOMED;
soloHigh     = h_SOLOHIGH;

bypass       = i_BYPASS;

inputMode    = j_input; // 0 = MS, 1 = XY (default = 1, estéreo normal)

lowBalance   = k_LOW_bal;
midBalance   = l_MED_bal;
highBalance  = m_HIGH_bal;

dryWet       = x_DRYWET;

muteLow      = n_MUTLOW;
muteMid      = o_MUTMED;
muteHigh     = p_MUTHIGH;

trimDb       = v_TRIM;
makeupDb     = w_MAKEUP;

// =============================================================================
// BLOQUE DE ENTRADA Y SUAVIZADO (TRIM / MAKEUP)
// =============================================================================
// Suavizado TRIM one-pole (a=0.999) — estéreo linkado
// =============================================================================
trimTarget = dbtoa(trimDb);

// Suavizador compartido (enlazado)
trimSharedNext = fixdenorm(0.999 * trimSharedHistory + 0.001 * trimTarget);

// Aplica el mismo valor a ambos canales
trimLeftNext  = trimSharedNext;
trimRightNext = trimSharedNext;

// Suavizado MAKEUP one-pole (a=0.999) — estéreo linkado // [REFAC-COMMENTS]
makeupTarget     = dbtoa(makeupDb);
makeupSharedNext = fixdenorm(0.999 * makeupSharedHistory + 0.001 * makeupTarget);
makeupLeftNext   = makeupSharedNext;
makeupRightNext  = makeupSharedNext;

// -----------------------------------------------------------------------------
// PUNTOS DE TOMA WET (POST-TRIM)
// -----------------------------------------------------------------------------
// Señal wet recortada tras TRIM; la rama seca permanece intacta
wetInL = in1 * trimLeftNext; // enlazado
wetInR = in2 * trimRightNext; // enlazado

// Monitor post-trim antes de procesado → out3/out4 // [REFAC-COMMENTS]
out3 = wetInL;
out4 = wetInR;

// =============================================================================
// HELPERS DE NORMALIZACION DE ANCHURA (ENERGIA RMS POR BANDA)
// =============================================================================
// FRECUENCIAS DE CRUCE DERIVADAS DE LOS PARAMETROS PUBLICOS
// =============================================================================
xoverLow  = clamp(freqLowHz,  20,  1000);
xoverHigh = clamp(freqHighHz, 1000, 20000);

// =============================================================================
// CRUCE LR4 (RAMO WET DERECHO)
// =============================================================================
wetRIn          = wetInR;
rightSampleRate = samplerate;
rightLowHz      = max(10, min(xoverLow, 0.45 * rightSampleRate));
rightHighPreHz  = max(10, min(xoverHigh, 0.45 * rightSampleRate));
rightHighHz     = max(rightHighPreHz, rightLowHz + 1);

rightW0Low    = (TWOPI * rightLowHz) / rightSampleRate;
rightCosLow   = cos(rightW0Low);
rightSinLow   = sin(rightW0Low);
rightAlphaLow = rightSinLow / sqrtTwoConstant;
rightA0Low    = 1 + rightAlphaLow;
rightA1Low    = -2 * rightCosLow;
rightA2Low    = 1 - rightAlphaLow;
rightLpB0Low  = ((1 - rightCosLow) * 0.5) / rightA0Low;
rightLpB1Low  = (1 - rightCosLow) / rightA0Low;
rightLpB2Low  = rightLpB0Low;
rightLpA1Low  = rightA1Low / rightA0Low;
rightLpA2Low  = rightA2Low / rightA0Low;
rightHpB0Low  = ((1 + rightCosLow) * 0.5) / rightA0Low;
rightHpB1Low  = (-(1 + rightCosLow)) / rightA0Low;
rightHpB2Low  = rightHpB0Low;
rightHpA1Low  = rightLpA1Low;
rightHpA2Low  = rightLpA2Low;

rightW0High    = (TWOPI * rightHighHz) / rightSampleRate;
rightCosHigh   = cos(rightW0High);
rightSinHigh   = sin(rightW0High);
rightAlphaHigh = rightSinHigh / sqrtTwoConstant;
rightA0High    = 1 + rightAlphaHigh;
rightA1High    = -2 * rightCosHigh;
rightA2High    = 1 - rightAlphaHigh;
rightLpB0High  = ((1 - rightCosHigh) * 0.5) / rightA0High;
rightLpB1High  = (1 - rightCosHigh) / rightA0High;
rightLpB2High  = rightLpB0High;
rightLpA1High  = rightA1High / rightA0High;
rightLpA2High  = rightA2High / rightA0High;
rightHpB0High  = ((1 + rightCosHigh) * 0.5) / rightA0High;
rightHpB1High  = (-(1 + rightCosHigh)) / rightA0High;
rightHpB2High  = rightHpB0High;
rightHpA1High  = rightLpA1High;
rightHpA2High  = rightLpA2High;

// Cascada rama baja (LP → LP)
wetRightLowStage1X1Prev = wetRightLowStage1X1;
wetRightLowStage1X2Prev = wetRightLowStage1X2;
wetRightLowStage1Y1Prev = wetRightLowStage1Y1;
wetRightLowStage1Y2Prev = wetRightLowStage1Y2;
wetRightLowStage1Sum = (rightLpB0Low * wetRIn) + (rightLpB1Low * wetRightLowStage1X1Prev) + (rightLpB2Low * wetRightLowStage1X2Prev);
wetRightLowStage1Out = (wetRightLowStage1Sum - (rightLpA1Low * wetRightLowStage1Y1Prev)) - (rightLpA2Low * wetRightLowStage1Y2Prev);
wetRightLowStage1X2 = wetRightLowStage1X1Prev;
wetRightLowStage1X1 = wetRIn;
wetRightLowStage1Y2 = wetRightLowStage1Y1Prev;
wetRightLowStage1Y1 = wetRightLowStage1Out;

wetRightLowStage2X1Prev = wetRightLowStage2X1;
wetRightLowStage2X2Prev = wetRightLowStage2X2;
wetRightLowStage2Y1Prev = wetRightLowStage2Y1;
wetRightLowStage2Y2Prev = wetRightLowStage2Y2;
wetRightLowStage2Sum = (rightLpB0Low * wetRightLowStage1Out) + (rightLpB1Low * wetRightLowStage2X1Prev) + (rightLpB2Low * wetRightLowStage2X2Prev);
wetRightLowStage2Out = (wetRightLowStage2Sum - (rightLpA1Low * wetRightLowStage2Y1Prev)) - (rightLpA2Low * wetRightLowStage2Y2Prev);
wetRightLowStage2X2 = wetRightLowStage2X1Prev;
wetRightLowStage2X1 = wetRightLowStage1Out;
wetRightLowStage2Y2 = wetRightLowStage2Y1Prev;
wetRightLowStage2Y1 = wetRightLowStage2Out;

// Cascada rama alta (HP → HP)
wetRightHighStage1X1Prev = wetRightHighStage1X1;
wetRightHighStage1X2Prev = wetRightHighStage1X2;
wetRightHighStage1Y1Prev = wetRightHighStage1Y1;
wetRightHighStage1Y2Prev = wetRightHighStage1Y2;
wetRightHighStage1Sum = (rightHpB0Low * wetRIn) + (rightHpB1Low * wetRightHighStage1X1Prev) + (rightHpB2Low * wetRightHighStage1X2Prev);
wetRightHighStage1Out = (wetRightHighStage1Sum - (rightHpA1Low * wetRightHighStage1Y1Prev)) - (rightHpA2Low * wetRightHighStage1Y2Prev);
wetRightHighStage1X2 = wetRightHighStage1X1Prev;
wetRightHighStage1X1 = wetRIn;
wetRightHighStage1Y2 = wetRightHighStage1Y1Prev;
wetRightHighStage1Y1 = wetRightHighStage1Out;

wetRightHighStage2X1Prev = wetRightHighStage2X1;
wetRightHighStage2X2Prev = wetRightHighStage2X2;
wetRightHighStage2Y1Prev = wetRightHighStage2Y1;
wetRightHighStage2Y2Prev = wetRightHighStage2Y2;
wetRightHighStage2Sum = (rightHpB0Low * wetRightHighStage1Out) + (rightHpB1Low * wetRightHighStage2X1Prev) + (rightHpB2Low * wetRightHighStage2X2Prev);
wetRightHighStage2Out = (wetRightHighStage2Sum - (rightHpA1Low * wetRightHighStage2Y1Prev)) - (rightHpA2Low * wetRightHighStage2Y2Prev);
wetRightHighStage2X2 = wetRightHighStage2X1Prev;
wetRightHighStage2X1 = wetRightHighStage1Out;
wetRightHighStage2Y2 = wetRightHighStage2Y1Prev;
wetRightHighStage2Y1 = wetRightHighStage2Out;

stage1OutR = wetRightLowStage2Out + wetRightHighStage2Out;

// Banda media (LP @ crossover alto)
wetRightMidStage1X1Prev = wetRightMidStage1X1;
wetRightMidStage1X2Prev = wetRightMidStage1X2;
wetRightMidStage1Y1Prev = wetRightMidStage1Y1;
wetRightMidStage1Y2Prev = wetRightMidStage1Y2;
wetRightMidStage1Sum = (rightLpB0High * stage1OutR) + (rightLpB1High * wetRightMidStage1X1Prev) + (rightLpB2High * wetRightMidStage1X2Prev);
wetRightMidStage1Out = (wetRightMidStage1Sum - (rightLpA1High * wetRightMidStage1Y1Prev)) - (rightLpA2High * wetRightMidStage1Y2Prev);
wetRightMidStage1X2 = wetRightMidStage1X1Prev;
wetRightMidStage1X1 = stage1OutR;
wetRightMidStage1Y2 = wetRightMidStage1Y1Prev;
wetRightMidStage1Y1 = wetRightMidStage1Out;

wetRightMidStage2X1Prev = wetRightMidStage2X1;
wetRightMidStage2X2Prev = wetRightMidStage2X2;
wetRightMidStage2Y1Prev = wetRightMidStage2Y1;
wetRightMidStage2Y2Prev = wetRightMidStage2Y2;
wetRightMidStage2Sum = (rightLpB0High * wetRightMidStage1Out) + (rightLpB1High * wetRightMidStage2X1Prev) + (rightLpB2High * wetRightMidStage2X2Prev);
wetRightMidStage2Out = (wetRightMidStage2Sum - (rightLpA1High * wetRightMidStage2Y1Prev)) - (rightLpA2High * wetRightMidStage2Y2Prev);
wetRightMidStage2X2 = wetRightMidStage2X1Prev;
wetRightMidStage2X1 = wetRightMidStage1Out;
wetRightMidStage2Y2 = wetRightMidStage2Y1Prev;
wetRightMidStage2Y1 = wetRightMidStage2Out;

// Banda alta (HP @ crossover alto)
wetRightHighBandStage1X1Prev = wetRightHighBandStage1X1;
wetRightHighBandStage1X2Prev = wetRightHighBandStage1X2;
wetRightHighBandStage1Y1Prev = wetRightHighBandStage1Y1;
wetRightHighBandStage1Y2Prev = wetRightHighBandStage1Y2;
wetRightHighBandStage1Sum = (rightHpB0High * stage1OutR) + (rightHpB1High * wetRightHighBandStage1X1Prev) + (rightHpB2High * wetRightHighBandStage1X2Prev);
wetRightHighBandStage1Out = (wetRightHighBandStage1Sum - (rightHpA1High * wetRightHighBandStage1Y1Prev)) - (rightHpA2High * wetRightHighBandStage1Y2Prev);
wetRightHighBandStage1X2 = wetRightHighBandStage1X1Prev;
wetRightHighBandStage1X1 = stage1OutR;
wetRightHighBandStage1Y2 = wetRightHighBandStage1Y1Prev;
wetRightHighBandStage1Y1 = wetRightHighBandStage1Out;

wetRightHighBandStage2X1Prev = wetRightHighBandStage2X1;
wetRightHighBandStage2X2Prev = wetRightHighBandStage2X2;
wetRightHighBandStage2Y1Prev = wetRightHighBandStage2Y1;
wetRightHighBandStage2Y2Prev = wetRightHighBandStage2Y2;
wetRightHighBandStage2Sum = (rightHpB0High * wetRightHighBandStage1Out) + (rightHpB1High * wetRightHighBandStage2X1Prev) + (rightHpB2High * wetRightHighBandStage2X2Prev);
wetRightHighBandStage2Out = (wetRightHighBandStage2Sum - (rightHpA1High * wetRightHighBandStage2Y1Prev)) - (rightHpA2High * wetRightHighBandStage2Y2Prev);
wetRightHighBandStage2X2 = wetRightHighBandStage2X1Prev;
wetRightHighBandStage2X1 = wetRightHighBandStage1Out;
wetRightHighBandStage2Y2 = wetRightHighBandStage2Y1Prev;
wetRightHighBandStage2Y1 = wetRightHighBandStage2Out;

// Alias para legibilidad (salidas crossover R)
lowBandR    = wetRightMidStage2Out;
highBandR   = wetRightHighBandStage2Out;
stage1SumR  = stage1OutR; // identidad: wetRightLowStage2Out + wetRightHighStage2Out
wetBandSumR = lowBandR + highBandR; // suma en línea para facilitar la lectura

// =============================================================================
// CRUCE LR4 (RAMO WET IZQUIERDO)
// =============================================================================
// Reflejo del LR4 derecho con nombres legibles para el canal izquierdo
wetLIn         = wetInL;
leftSampleRate = samplerate;
leftLowHz      = max(10, min(xoverLow, 0.45 * leftSampleRate));
leftHighPreHz  = max(10, min(xoverHigh, 0.45 * leftSampleRate));
leftHighHz     = max(leftHighPreHz, leftLowHz + 1);

leftW0Low    = (TWOPI * leftLowHz) / leftSampleRate;
leftCosLow   = cos(leftW0Low);
leftSinLow   = sin(leftW0Low);
leftAlphaLow = leftSinLow / sqrtTwoConstant;
leftA0Low    = 1 + leftAlphaLow;
leftA1Low    = -2 * leftCosLow;
leftA2Low    = 1 - leftAlphaLow;
leftLpB0Low  = ((1 - leftCosLow) * 0.5) / leftA0Low;
leftLpB1Low  = (1 - leftCosLow) / leftA0Low;
leftLpB2Low  = leftLpB0Low;
leftLpA1Low  = leftA1Low / leftA0Low;
leftLpA2Low  = leftA2Low / leftA0Low;
leftHpB0Low  = ((1 + leftCosLow) * 0.5) / leftA0Low;
leftHpB1Low  = (-(1 + leftCosLow)) / leftA0Low;
leftHpB2Low  = leftHpB0Low;
leftHpA1Low  = leftLpA1Low;
leftHpA2Low  = leftLpA2Low;

leftW0High    = (TWOPI * leftHighHz) / leftSampleRate;
leftCosHigh   = cos(leftW0High);
leftSinHigh   = sin(leftW0High);
leftAlphaHigh = leftSinHigh / sqrtTwoConstant;
leftA0High    = 1 + leftAlphaHigh;
leftA1High    = -2 * leftCosHigh;
leftA2High    = 1 - leftAlphaHigh;
leftLpB0High  = ((1 - leftCosHigh) * 0.5) / leftA0High;
leftLpB1High  = (1 - leftCosHigh) / leftA0High;
leftLpB2High  = leftLpB0High;
leftLpA1High  = leftA1High / leftA0High;
leftLpA2High  = leftA2High / leftA0High;
leftHpB0High  = ((1 + leftCosHigh) * 0.5) / leftA0High;
leftHpB1High  = (-(1 + leftCosHigh)) / leftA0High;
leftHpB2High  = leftHpB0High;
leftHpA1High  = leftLpA1High;
leftHpA2High  = leftLpA2High;

// Cascada rama baja (LP → LP)
wetLeftLowStage1X1Prev = wetLeftLowStage1X1;
wetLeftLowStage1X2Prev = wetLeftLowStage1X2;
wetLeftLowStage1Y1Prev = wetLeftLowStage1Y1;
wetLeftLowStage1Y2Prev = wetLeftLowStage1Y2;
wetLeftLowStage1Sum = (leftLpB0Low * wetLIn) + (leftLpB1Low * wetLeftLowStage1X1Prev) + (leftLpB2Low * wetLeftLowStage1X2Prev);
wetLeftLowStage1Out = (wetLeftLowStage1Sum - (leftLpA1Low * wetLeftLowStage1Y1Prev)) - (leftLpA2Low * wetLeftLowStage1Y2Prev);
wetLeftLowStage1X2 = wetLeftLowStage1X1Prev;
wetLeftLowStage1X1 = wetLIn;
wetLeftLowStage1Y2 = wetLeftLowStage1Y1Prev;
wetLeftLowStage1Y1 = wetLeftLowStage1Out;

wetLeftLowStage2X1Prev = wetLeftLowStage2X1;
wetLeftLowStage2X2Prev = wetLeftLowStage2X2;
wetLeftLowStage2Y1Prev = wetLeftLowStage2Y1;
wetLeftLowStage2Y2Prev = wetLeftLowStage2Y2;
wetLeftLowStage2Sum = (leftLpB0Low * wetLeftLowStage1Out) + (leftLpB1Low * wetLeftLowStage2X1Prev) + (leftLpB2Low * wetLeftLowStage2X2Prev);
wetLeftLowStage2Out = (wetLeftLowStage2Sum - (leftLpA1Low * wetLeftLowStage2Y1Prev)) - (leftLpA2Low * wetLeftLowStage2Y2Prev);
wetLeftLowStage2X2 = wetLeftLowStage2X1Prev;
wetLeftLowStage2X1 = wetLeftLowStage1Out;
wetLeftLowStage2Y2 = wetLeftLowStage2Y1Prev;
wetLeftLowStage2Y1 = wetLeftLowStage2Out;

// Cascada rama alta (HP → HP)
wetLeftHighStage1X1Prev = wetLeftHighStage1X1;
wetLeftHighStage1X2Prev = wetLeftHighStage1X2;
wetLeftHighStage1Y1Prev = wetLeftHighStage1Y1;
wetLeftHighStage1Y2Prev = wetLeftHighStage1Y2;
wetLeftHighStage1Sum = (leftHpB0Low * wetLIn) + (leftHpB1Low * wetLeftHighStage1X1Prev) + (leftHpB2Low * wetLeftHighStage1X2Prev);
wetLeftHighStage1Out = (wetLeftHighStage1Sum - (leftHpA1Low * wetLeftHighStage1Y1Prev)) - (leftHpA2Low * wetLeftHighStage1Y2Prev);
wetLeftHighStage1X2 = wetLeftHighStage1X1Prev;
wetLeftHighStage1X1 = wetLIn;
wetLeftHighStage1Y2 = wetLeftHighStage1Y1Prev;
wetLeftHighStage1Y1 = wetLeftHighStage1Out;

wetLeftHighStage2X1Prev = wetLeftHighStage2X1;
wetLeftHighStage2X2Prev = wetLeftHighStage2X2;
wetLeftHighStage2Y1Prev = wetLeftHighStage2Y1;
wetLeftHighStage2Y2Prev = wetLeftHighStage2Y2;
wetLeftHighStage2Sum = (leftHpB0Low * wetLeftHighStage1Out) + (leftHpB1Low * wetLeftHighStage2X1Prev) + (leftHpB2Low * wetLeftHighStage2X2Prev);
wetLeftHighStage2Out = (wetLeftHighStage2Sum - (leftHpA1Low * wetLeftHighStage2Y1Prev)) - (leftHpA2Low * wetLeftHighStage2Y2Prev);
wetLeftHighStage2X2 = wetLeftHighStage2X1Prev;
wetLeftHighStage2X1 = wetLeftHighStage1Out;
wetLeftHighStage2Y2 = wetLeftHighStage2Y1Prev;
wetLeftHighStage2Y1 = wetLeftHighStage2Out;

stage1OutL = wetLeftLowStage2Out + wetLeftHighStage2Out;

// Banda media (LP @ crossover alto)
wetLeftMidStage1X1Prev = wetLeftMidStage1X1;
wetLeftMidStage1X2Prev = wetLeftMidStage1X2;
wetLeftMidStage1Y1Prev = wetLeftMidStage1Y1;
wetLeftMidStage1Y2Prev = wetLeftMidStage1Y2;
wetLeftMidStage1Sum = (leftLpB0High * stage1OutL) + (leftLpB1High * wetLeftMidStage1X1Prev) + (leftLpB2High * wetLeftMidStage1X2Prev);
wetLeftMidStage1Out = (wetLeftMidStage1Sum - (leftLpA1High * wetLeftMidStage1Y1Prev)) - (leftLpA2High * wetLeftMidStage1Y2Prev);
wetLeftMidStage1X2 = wetLeftMidStage1X1Prev;
wetLeftMidStage1X1 = stage1OutL;
wetLeftMidStage1Y2 = wetLeftMidStage1Y1Prev;
wetLeftMidStage1Y1 = wetLeftMidStage1Out;

wetLeftMidStage2X1Prev = wetLeftMidStage2X1;
wetLeftMidStage2X2Prev = wetLeftMidStage2X2;
wetLeftMidStage2Y1Prev = wetLeftMidStage2Y1;
wetLeftMidStage2Y2Prev = wetLeftMidStage2Y2;
wetLeftMidStage2Sum = (leftLpB0High * wetLeftMidStage1Out) + (leftLpB1High * wetLeftMidStage2X1Prev) + (leftLpB2High * wetLeftMidStage2X2Prev);
wetLeftMidStage2Out = (wetLeftMidStage2Sum - (leftLpA1High * wetLeftMidStage2Y1Prev)) - (leftLpA2High * wetLeftMidStage2Y2Prev);
wetLeftMidStage2X2 = wetLeftMidStage2X1Prev;
wetLeftMidStage2X1 = wetLeftMidStage1Out;
wetLeftMidStage2Y2 = wetLeftMidStage2Y1Prev;
wetLeftMidStage2Y1 = wetLeftMidStage2Out;

// Banda alta (HP @ crossover alto)
wetLeftHighBandStage1X1Prev = wetLeftHighBandStage1X1;
wetLeftHighBandStage1X2Prev = wetLeftHighBandStage1X2;
wetLeftHighBandStage1Y1Prev = wetLeftHighBandStage1Y1;
wetLeftHighBandStage1Y2Prev = wetLeftHighBandStage1Y2;
wetLeftHighBandStage1Sum = (leftHpB0High * stage1OutL) + (leftHpB1High * wetLeftHighBandStage1X1Prev) + (leftHpB2High * wetLeftHighBandStage1X2Prev);
wetLeftHighBandStage1Out = (wetLeftHighBandStage1Sum - (leftHpA1High * wetLeftHighBandStage1Y1Prev)) - (leftHpA2High * wetLeftHighBandStage1Y2Prev);
wetLeftHighBandStage1X2 = wetLeftHighBandStage1X1Prev;
wetLeftHighBandStage1X1 = stage1OutL;
wetLeftHighBandStage1Y2 = wetLeftHighBandStage1Y1Prev;
wetLeftHighBandStage1Y1 = wetLeftHighBandStage1Out;

wetLeftHighBandStage2X1Prev = wetLeftHighBandStage2X1;
wetLeftHighBandStage2X2Prev = wetLeftHighBandStage2X2;
wetLeftHighBandStage2Y1Prev = wetLeftHighBandStage2Y1;
wetLeftHighBandStage2Y2Prev = wetLeftHighBandStage2Y2;
wetLeftHighBandStage2Sum = (leftHpB0High * wetLeftHighBandStage1Out) + (leftHpB1High * wetLeftHighBandStage2X1Prev) + (leftHpB2High * wetLeftHighBandStage2X2Prev);
wetLeftHighBandStage2Out = (wetLeftHighBandStage2Sum - (leftHpA1High * wetLeftHighBandStage2Y1Prev)) - (leftHpA2High * wetLeftHighBandStage2Y2Prev);
wetLeftHighBandStage2X2 = wetLeftHighBandStage2X1Prev;
wetLeftHighBandStage2X1 = wetLeftHighBandStage1Out;
wetLeftHighBandStage2Y2 = wetLeftHighBandStage2Y1Prev;
wetLeftHighBandStage2Y1 = wetLeftHighBandStage2Out;

// Alias para legibilidad (salidas crossover L)
lowBandL    = wetLeftMidStage2Out;
highBandL   = wetLeftHighBandStage2Out;
stage1SumL  = stage1OutL; // identidad: low + high
wetBandSumL = lowBandL + highBandL;

// =============================================================================
// SUAVIZADO DE CONTROLES GLOBALES (DRYWET/BYPASS/SOLOS)
// =============================================================================
dryWetSlew        = slewDefault;
dryWetSmoothed    = mix(dryWet, dryWetHistory, dryWetSlew);
dryWetControl     = dryWetSmoothed;
dryWetHistoryNext = fixdenorm(dryWetSmoothed);

bypassSlew        = slewDefault;
bypassSmoothed    = mix(bypass, bypassHistory, bypassSlew);
bypassHistoryNext = fixdenorm(bypassSmoothed);
bypassMask        = 1 - bypassSmoothed;

soloZero           = int(0);
soloMidSlew        = slewDefault;
soloMidSmoothed    = mix(soloMid, soloMidHistory, soloMidSlew);
soloMidHistoryNext = fixdenorm(soloMidSmoothed);

soloHighSlew        = slewDefault;
soloHighSmoothed    = mix(soloHigh, soloHighHistory, soloHighSlew);
soloHighHistoryNext = fixdenorm(soloHighSmoothed);

soloMidZero     = int(0);
soloLowSlew     = slewDefault;
soloLowSmoothed = mix(soloLow, soloLowHistory, soloLowSlew);

// Alias para la etapa de suavizado de solos
soloMidSm  = soloMidSmoothed;
soloHighSm = soloHighSmoothed;
soloLowSm  = soloLowSmoothed;

// Máscaras de solo por banda
soloMaskLow  = soloHighSm + soloMidSm;  // silencia LOW cuando MID o HIGH están en solo
soloMaskMid  = soloHighSm + soloLowSm;  // silencia MID cuando HIGH o LOW están en solo
soloMaskHigh = soloMidSm  + soloLowSm;  // silencia HIGH cuando MID o LOW están en solo
soloLowHistoryNext = fixdenorm(soloLowSmoothed);
soloHighZero       = int(0);

// Los relés setparam con nombre mantienen legible la automatización del host
setparamLowBalance     = lowBalance;
inputModeSlew          = slewDefault;
inputModeSmoothed      = mix(inputMode, inputModeHistory, inputModeSlew);
inputModeHistoryNext   = fixdenorm(inputModeSmoothed);
setparamInputMode      = inputModeSmoothed;
setparamInputModeReset = int(0);

lowBandGainSlew        = slewDefault;
lowBandGainSmoothed    = mix(bandLowGain, lowBandGainHistory, lowBandGainSlew);
lowBandGainHistoryNext = fixdenorm(lowBandGainSmoothed);
setparamLowGain        = lowBandGainSmoothed;

setparamLowGainReset = int(0);

midBandGainSlew        = slewDefault;
midBandGainSmoothed    = mix(bandMidGain, midBandGainHistory, midBandGainSlew);
midBandGainHistoryNext = fixdenorm(midBandGainSmoothed);
setparamMidGain        = midBandGainSmoothed;

midBalanceSlew        = slewDefault;
midBalanceSmoothed    = mix(midBalance, midBalanceHistory, midBalanceSlew);
midBalanceHistoryNext = fixdenorm(midBalanceSmoothed);
setparamMidBalance    = midBalanceSmoothed;

setparamMidGainReset = int(0);

highBandGainSlew        = slewDefault;
highBandGainSmoothed    = mix(bandHighGain, highBandGainHistory, highBandGainSlew);
highBandGainHistoryNext = fixdenorm(highBandGainSmoothed);
setparamHighGain        = highBandGainSmoothed;

highBalanceSlew        = slewDefault;
highBalanceSmoothed    = mix(highBalance, highBalanceHistory, highBalanceSlew);
highBalanceHistoryNext = fixdenorm(highBalanceSmoothed);
setparamHighBalance    = highBalanceSmoothed;

highCrossoverSlew        = slewDefault;
highCrossoverSmoothed    = mix(freqHighHz, highCrossoverHistory, highCrossoverSlew);
highCrossoverHistoryNext = fixdenorm(highCrossoverSmoothed);
setparamHighCrossover    = highCrossoverSmoothed;

lowCrossoverSlew        = slewDefault;
lowCrossoverSmoothed    = mix(freqLowHz, lowCrossoverHistory, lowCrossoverSlew);
lowCrossoverHistoryNext = fixdenorm(lowCrossoverSmoothed);
setparamLowCrossover    = lowCrossoverSmoothed;

// Red LR4/all-pass seca izquierda con nombres legibles
leftLowTargetHz   = clamp(setparamLowCrossover, 20, 1000);
leftHighTargetHz  = clamp(setparamHighCrossover, 1000, 20000);
dryLeftInput      = wetInL;
dryLeftSampleRate = samplerate;

leftLowHz     = max(10, min(leftLowTargetHz, 0.45 * dryLeftSampleRate));
leftHighPreHz = max(10, min(leftHighTargetHz, 0.45 * dryLeftSampleRate));
leftHighHz    = max(leftHighPreHz, leftLowHz + 1);

leftDryW0Low    = (TWOPI * leftLowHz) / dryLeftSampleRate;
leftDryCosLow   = cos(leftDryW0Low);
leftDrySinLow   = sin(leftDryW0Low);
leftDryAlphaLow = leftDrySinLow / sqrtTwoConstant;
leftDryA0Low    = 1 + leftDryAlphaLow;
leftDryA1Low    = -2 * leftDryCosLow;
leftDryA2Low    = 1 - leftDryAlphaLow;
leftDryLpB0Low  = ((1 - leftDryCosLow) * 0.5) / leftDryA0Low;
leftDryLpB1Low  = (1 - leftDryCosLow) / leftDryA0Low;
leftDryLpB2Low  = leftDryLpB0Low;
leftDryLpA1Low  = leftDryA1Low / leftDryA0Low;
leftDryLpA2Low  = leftDryA2Low / leftDryA0Low;
leftDryHpB0Low  = ((1 + leftDryCosLow) * 0.5) / leftDryA0Low;
leftDryHpB1Low  = (-(1 + leftDryCosLow)) / leftDryA0Low;
leftDryHpB2Low  = leftDryHpB0Low;
leftDryHpA1Low  = leftDryLpA1Low;
leftDryHpA2Low  = leftDryLpA2Low;

leftDryW0High    = (TWOPI * leftHighHz) / dryLeftSampleRate;
leftDryCosHigh   = cos(leftDryW0High);
leftDrySinHigh   = sin(leftDryW0High);
leftDryAlphaHigh = leftDrySinHigh / sqrtTwoConstant;
leftDryA0High    = 1 + leftDryAlphaHigh;
leftDryA1High    = -2 * leftDryCosHigh;
leftDryA2High    = 1 - leftDryAlphaHigh;
leftDryLpB0High  = ((1 - leftDryCosHigh) * 0.5) / leftDryA0High;
leftDryLpB1High  = (1 - leftDryCosHigh) / leftDryA0High;
leftDryLpB2High  = leftDryLpB0High;
leftDryLpA1High  = leftDryA1High / leftDryA0High;
leftDryLpA2High  = leftDryA2High / leftDryA0High;
leftDryHpB0High  = ((1 + leftDryCosHigh) * 0.5) / leftDryA0High;
leftDryHpB1High  = (-(1 + leftDryCosHigh)) / leftDryA0High;
leftDryHpB2High  = leftDryHpB0High;
leftDryHpA1High  = leftDryLpA1High;
leftDryHpA2High  = leftDryLpA2High;

// Cascada rama baja (LP → LP)
dryLeftLowStage1X1Prev = fixdenorm(dryLeftLowLpStage1X1);
dryLeftLowStage1X2Prev = fixdenorm(dryLeftLowLpStage1X2);
dryLeftLowStage1Y1Prev = fixdenorm(dryLeftLowLpStage1Y1);
dryLeftLowStage1Y2Prev = fixdenorm(dryLeftLowLpStage1Y2);
dryLeftLowStage1Sum = (leftDryLpB0Low * dryLeftInput) + (leftDryLpB1Low * dryLeftLowStage1X1Prev) + (leftDryLpB2Low * dryLeftLowStage1X2Prev);
dryLeftLowStage1Out = (dryLeftLowStage1Sum - (leftDryLpA1Low * dryLeftLowStage1Y1Prev)) - (leftDryLpA2Low * dryLeftLowStage1Y2Prev);
dryLeftLowLpStage1X2 = dryLeftLowStage1X1Prev;
dryLeftLowLpStage1X1 = dryLeftInput;
dryLeftLowLpStage1Y2 = dryLeftLowStage1Y1Prev;
dryLeftLowLpStage1Y1 = dryLeftLowStage1Out;

dryLeftLowStage2X1Prev = fixdenorm(dryLeftLowLpStage2X1);
dryLeftLowStage2X2Prev = fixdenorm(dryLeftLowLpStage2X2);
dryLeftLowStage2Y1Prev = fixdenorm(dryLeftLowLpStage2Y1);
dryLeftLowStage2Y2Prev = fixdenorm(dryLeftLowLpStage2Y2);
dryLeftLowStage2Sum = (leftDryLpB0Low * dryLeftLowStage1Out) + (leftDryLpB1Low * dryLeftLowStage2X1Prev) + (leftDryLpB2Low * dryLeftLowStage2X2Prev);
dryLeftLowStage2Out = (dryLeftLowStage2Sum - (leftDryLpA1Low * dryLeftLowStage2Y1Prev)) - (leftDryLpA2Low * dryLeftLowStage2Y2Prev);
dryLeftLowLpStage2X2 = dryLeftLowStage2X1Prev;
dryLeftLowLpStage2X1 = dryLeftLowStage1Out;
dryLeftLowLpStage2Y2 = dryLeftLowStage2Y1Prev;
dryLeftLowLpStage2Y1 = dryLeftLowStage2Out;

// Cascada rama alta (HP → HP)
dryLeftHighStage1X1Prev = fixdenorm(dryLeftLowHpStage1X1);
dryLeftHighStage1X2Prev = fixdenorm(dryLeftLowHpStage1X2);
dryLeftHighStage1Y1Prev = fixdenorm(dryLeftLowHpStage1Y1);
dryLeftHighStage1Y2Prev = fixdenorm(dryLeftLowHpStage1Y2);
dryLeftHighStage1Sum = (leftDryHpB0Low * dryLeftInput) + (leftDryHpB1Low * dryLeftHighStage1X1Prev) + (leftDryHpB2Low * dryLeftHighStage1X2Prev);
dryLeftHighStage1Out = (dryLeftHighStage1Sum - (leftDryHpA1Low * dryLeftHighStage1Y1Prev)) - (leftDryHpA2Low * dryLeftHighStage1Y2Prev);
dryLeftLowHpStage1X2 = dryLeftHighStage1X1Prev;
dryLeftLowHpStage1X1 = dryLeftInput;
dryLeftLowHpStage1Y2 = dryLeftHighStage1Y1Prev;
dryLeftLowHpStage1Y1 = dryLeftHighStage1Out;

dryLeftHighStage2X1Prev = fixdenorm(dryLeftLowHpStage2X1);
dryLeftHighStage2X2Prev = fixdenorm(dryLeftLowHpStage2X2);
dryLeftHighStage2Y1Prev = fixdenorm(dryLeftLowHpStage2Y1);
dryLeftHighStage2Y2Prev = fixdenorm(dryLeftLowHpStage2Y2);
dryLeftHighStage2Sum = (leftDryHpB0Low * dryLeftHighStage1Out) + (leftDryHpB1Low * dryLeftHighStage2X1Prev) + (leftDryHpB2Low * dryLeftHighStage2X2Prev);
dryLeftHighStage2Out = (dryLeftHighStage2Sum - (leftDryHpA1Low * dryLeftHighStage2Y1Prev)) - (leftDryHpA2Low * dryLeftHighStage2Y2Prev);
dryLeftLowHpStage2X2 = dryLeftHighStage2X1Prev;
dryLeftLowHpStage2X1 = dryLeftHighStage1Out;
dryLeftLowHpStage2Y2 = dryLeftHighStage2Y1Prev;
dryLeftLowHpStage2Y1 = dryLeftHighStage2Out;

// Compensación all-pass (banda baja)
dryLeftApLowLpStage1X1Prev = fixdenorm(apLeftLowLpStage1X1);
dryLeftApLowLpStage1X2Prev = fixdenorm(apLeftLowLpStage1X2);
dryLeftApLowLpStage1Y1Prev = fixdenorm(apLeftLowLpStage1Y1);
dryLeftApLowLpStage1Y2Prev = fixdenorm(apLeftLowLpStage1Y2);
dryLeftApLowLpStage1Sum = (leftDryLpB0High * dryLeftLowStage2Out) + (leftDryLpB1High * dryLeftApLowLpStage1X1Prev) + (leftDryLpB2High * dryLeftApLowLpStage1X2Prev);
dryLeftApLowLpStage1Out = (dryLeftApLowLpStage1Sum - (leftDryLpA1High * dryLeftApLowLpStage1Y1Prev)) - (leftDryLpA2High * dryLeftApLowLpStage1Y2Prev);
apLeftLowLpStage1X2 = dryLeftApLowLpStage1X1Prev;
apLeftLowLpStage1X1 = dryLeftLowStage2Out;
apLeftLowLpStage1Y2 = dryLeftApLowLpStage1Y1Prev;
apLeftLowLpStage1Y1 = dryLeftApLowLpStage1Out;

dryLeftApLowLpStage2X1Prev = fixdenorm(apLeftLowLpStage2X1);
dryLeftApLowLpStage2X2Prev = fixdenorm(apLeftLowLpStage2X2);
dryLeftApLowLpStage2Y1Prev = fixdenorm(apLeftLowLpStage2Y1);
dryLeftApLowLpStage2Y2Prev = fixdenorm(apLeftLowLpStage2Y2);
dryLeftApLowLpStage2Sum = (leftDryLpB0High * dryLeftApLowLpStage1Out) + (leftDryLpB1High * dryLeftApLowLpStage2X1Prev) + (leftDryLpB2High * dryLeftApLowLpStage2X2Prev);
dryLeftApLowLpStage2Out = (dryLeftApLowLpStage2Sum - (leftDryLpA1High * dryLeftApLowLpStage2Y1Prev)) - (leftDryLpA2High * dryLeftApLowLpStage2Y2Prev);
apLeftLowLpStage2X2 = dryLeftApLowLpStage2X1Prev;
apLeftLowLpStage2X1 = dryLeftApLowLpStage1Out;
apLeftLowLpStage2Y2 = dryLeftApLowLpStage2Y1Prev;
apLeftLowLpStage2Y1 = dryLeftApLowLpStage2Out;

dryLeftApLowHpStage1X1Prev = fixdenorm(apLeftLowHpStage1X1);
dryLeftApLowHpStage1X2Prev = fixdenorm(apLeftLowHpStage1X2);
dryLeftApLowHpStage1Y1Prev = fixdenorm(apLeftLowHpStage1Y1);
dryLeftApLowHpStage1Y2Prev = fixdenorm(apLeftLowHpStage1Y2);
dryLeftApLowHpStage1Sum = (leftDryHpB0High * dryLeftLowStage2Out) + (leftDryHpB1High * dryLeftApLowHpStage1X1Prev) + (leftDryHpB2High * dryLeftApLowHpStage1X2Prev);
dryLeftApLowHpStage1Out = (dryLeftApLowHpStage1Sum - (leftDryHpA1High * dryLeftApLowHpStage1Y1Prev)) - (leftDryHpA2High * dryLeftApLowHpStage1Y2Prev);
apLeftLowHpStage1X2 = dryLeftApLowHpStage1X1Prev;
apLeftLowHpStage1X1 = dryLeftLowStage2Out;
apLeftLowHpStage1Y2 = dryLeftApLowHpStage1Y1Prev;
apLeftLowHpStage1Y1 = dryLeftApLowHpStage1Out;

dryLeftApLowHpStage2X1Prev = fixdenorm(apLeftLowHpStage2X1);
dryLeftApLowHpStage2X2Prev = fixdenorm(apLeftLowHpStage2X2);
dryLeftApLowHpStage2Y1Prev = fixdenorm(apLeftLowHpStage2Y1);
dryLeftApLowHpStage2Y2Prev = fixdenorm(apLeftLowHpStage2Y2);
dryLeftApLowHpStage2Sum = (leftDryHpB0High * dryLeftApLowHpStage1Out) + (leftDryHpB1High * dryLeftApLowHpStage2X1Prev) + (leftDryHpB2High * dryLeftApLowHpStage2X2Prev);
dryLeftApLowHpStage2Out = (dryLeftApLowHpStage2Sum - (leftDryHpA1High * dryLeftApLowHpStage2Y1Prev)) - (leftDryHpA2High * dryLeftApLowHpStage2Y2Prev);
apLeftLowHpStage2X2 = dryLeftApLowHpStage2X1Prev;
apLeftLowHpStage2X1 = dryLeftApLowHpStage1Out;
apLeftLowHpStage2Y2 = dryLeftApLowHpStage2Y1Prev;
apLeftLowHpStage2Y1 = dryLeftApLowHpStage2Out;

dryLeftLowBand = dryLeftApLowLpStage2Out + dryLeftApLowHpStage2Out;

// Banda media (LP @ crossover alto)
dryLeftMidStage1X1Prev = fixdenorm(dryLeftMidLpStage1X1);
dryLeftMidStage1X2Prev = fixdenorm(dryLeftMidLpStage1X2);
dryLeftMidStage1Y1Prev = fixdenorm(dryLeftMidLpStage1Y1);
dryLeftMidStage1Y2Prev = fixdenorm(dryLeftMidLpStage1Y2);
dryLeftMidStage1Sum = (leftDryLpB0High * dryLeftHighStage2Out) + (leftDryLpB1High * dryLeftMidStage1X1Prev) + (leftDryLpB2High * dryLeftMidStage1X2Prev);
dryLeftMidStage1Out = (dryLeftMidStage1Sum - (leftDryLpA1High * dryLeftMidStage1Y1Prev)) - (leftDryLpA2High * dryLeftMidStage1Y2Prev);
dryLeftMidLpStage1X2 = dryLeftMidStage1X1Prev;
dryLeftMidLpStage1X1 = dryLeftHighStage2Out;
dryLeftMidLpStage1Y2 = dryLeftMidStage1Y1Prev;
dryLeftMidLpStage1Y1 = dryLeftMidStage1Out;

dryLeftMidStage2X1Prev = fixdenorm(dryLeftMidLpStage2X1);
dryLeftMidStage2X2Prev = fixdenorm(dryLeftMidLpStage2X2);
dryLeftMidStage2Y1Prev = fixdenorm(dryLeftMidLpStage2Y1);
dryLeftMidStage2Y2Prev = fixdenorm(dryLeftMidLpStage2Y2);
dryLeftMidStage2Sum = (leftDryLpB0High * dryLeftMidStage1Out) + (leftDryLpB1High * dryLeftMidStage2X1Prev) + (leftDryLpB2High * dryLeftMidStage2X2Prev);
dryLeftMidStage2Out = (dryLeftMidStage2Sum - (leftDryLpA1High * dryLeftMidStage2Y1Prev)) - (leftDryLpA2High * dryLeftMidStage2Y2Prev);
dryLeftMidLpStage2X2 = dryLeftMidStage2X1Prev;
dryLeftMidLpStage2X1 = dryLeftMidStage1Out;
dryLeftMidLpStage2Y2 = dryLeftMidStage2Y1Prev;
dryLeftMidLpStage2Y1 = dryLeftMidStage2Out;

dryLeftMidBand = dryLeftMidStage2Out;

// Banda alta (HP @ crossover alto)
dryLeftHighBandStage1X1Prev = fixdenorm(dryLeftHighHpStage1X1);
dryLeftHighBandStage1X2Prev = fixdenorm(dryLeftHighHpStage1X2);
dryLeftHighBandStage1Y1Prev = fixdenorm(dryLeftHighHpStage1Y1);
dryLeftHighBandStage1Y2Prev = fixdenorm(dryLeftHighHpStage1Y2);
dryLeftHighBandStage1Sum = (leftDryHpB0High * dryLeftHighStage2Out) + (leftDryHpB1High * dryLeftHighBandStage1X1Prev) + (leftDryHpB2High * dryLeftHighBandStage1X2Prev);
dryLeftHighBandStage1Out = (dryLeftHighBandStage1Sum - (leftDryHpA1High * dryLeftHighBandStage1Y1Prev)) - (leftDryHpA2High * dryLeftHighBandStage1Y2Prev);
dryLeftHighHpStage1X2 = dryLeftHighBandStage1X1Prev;
dryLeftHighHpStage1X1 = dryLeftHighStage2Out;
dryLeftHighHpStage1Y2 = dryLeftHighBandStage1Y1Prev;
dryLeftHighHpStage1Y1 = dryLeftHighBandStage1Out;

dryLeftHighBandStage2X1Prev = fixdenorm(dryLeftHighHpStage2X1);
dryLeftHighBandStage2X2Prev = fixdenorm(dryLeftHighHpStage2X2);
dryLeftHighBandStage2Y1Prev = fixdenorm(dryLeftHighHpStage2Y1);
dryLeftHighBandStage2Y2Prev = fixdenorm(dryLeftHighHpStage2Y2);
dryLeftHighBandStage2Sum = (leftDryHpB0High * dryLeftHighBandStage1Out) + (leftDryHpB1High * dryLeftHighBandStage2X1Prev) + (leftDryHpB2High * dryLeftHighBandStage2X2Prev);
dryLeftHighBandStage2Out = (dryLeftHighBandStage2Sum - (leftDryHpA1High * dryLeftHighBandStage2Y1Prev)) - (leftDryHpA2High * dryLeftHighBandStage2Y2Prev);
dryLeftHighHpStage2X2 = dryLeftHighBandStage2X1Prev;
dryLeftHighHpStage2X1 = dryLeftHighBandStage1Out;
dryLeftHighHpStage2Y2 = dryLeftHighBandStage2Y1Prev;
dryLeftHighHpStage2Y1 = dryLeftHighBandStage2Out;

dryLeftHighBand = dryLeftHighBandStage2Out;
dryLeftSumBands = (dryLeftLowBand + dryLeftMidBand) + dryLeftHighBand;

// Alias para las divisiones en 3 bandas (L) → entradas a LOW/MID/HIGH
lowLIn  = dryLeftLowBand;
midLIn  = dryLeftMidBand;
highLIn = dryLeftHighBand;

// Alias opcional con la suma L
sum3BandL = dryLeftSumBands;

// La ruta dry fuerza la misma reconstrucción de 3 bandas que la rama wet
wetBandSumL = sum3BandL;

// =============================================================================
// COMPENSACION DE FASE EN LA RUTA DRY
//   • Reaplica divisiones LR4 en la señal dry para igualar latencia/fase wet
//   • All-pass (apLow*/dryLow*) aseguran suma coherente en la mezcla final
// =============================================================================
// Nombres y estructura de la rama derecha más legibles
rightLowTargetHz   = clamp(setparamLowCrossover, 20, 1000);
rightHighTargetHz  = clamp(setparamHighCrossover, 1000, 20000);
dryRightInput      = wetInR;
dryRightSampleRate = samplerate;

rightLowHz     = max(10, min(rightLowTargetHz, 0.45 * dryRightSampleRate));
rightHighPreHz = max(10, min(rightHighTargetHz, 0.45 * dryRightSampleRate));
rightHighHz    = max(rightHighPreHz, rightLowHz + 1);

rightW0Low    = (TWOPI * rightLowHz) / dryRightSampleRate;
rightCosLow   = cos(rightW0Low);
rightSinLow   = sin(rightW0Low);
rightAlphaLow = rightSinLow / sqrtTwoConstant;
rightA0Low    = 1 + rightAlphaLow;
rightA1Low    = -2 * rightCosLow;
rightA2Low    = 1 - rightAlphaLow;
rightLpB0Low  = ((1 - rightCosLow) * 0.5) / rightA0Low;
rightLpB1Low  = (1 - rightCosLow) / rightA0Low;
rightLpB2Low  = rightLpB0Low;
rightLpA1Low  = rightA1Low / rightA0Low;
rightLpA2Low  = rightA2Low / rightA0Low;
rightHpB0Low  = ((1 + rightCosLow) * 0.5) / rightA0Low;
rightHpB1Low  = (-(1 + rightCosLow)) / rightA0Low;
rightHpB2Low  = rightHpB0Low;
rightHpA1Low  = rightLpA1Low;
rightHpA2Low  = rightLpA2Low;

rightW0High    = (TWOPI * rightHighHz) / dryRightSampleRate;
rightCosHigh   = cos(rightW0High);
rightSinHigh   = sin(rightW0High);
rightAlphaHigh = rightSinHigh / sqrtTwoConstant;
rightA0High    = 1 + rightAlphaHigh;
rightA1High    = -2 * rightCosHigh;
rightA2High    = 1 - rightAlphaHigh;
rightLpB0High  = ((1 - rightCosHigh) * 0.5) / rightA0High;
rightLpB1High  = (1 - rightCosHigh) / rightA0High;
rightLpB2High  = rightLpB0High;
rightLpA1High  = rightA1High / rightA0High;
rightLpA2High  = rightA2High / rightA0High;
rightHpB0High  = ((1 + rightCosHigh) * 0.5) / rightA0High;
rightHpB1High  = (-(1 + rightCosHigh)) / rightA0High;
rightHpB2High  = rightHpB0High;
rightHpA1High  = rightLpA1High;
rightHpA2High  = rightLpA2High;

// Cascada rama baja (LP → LP)
rightLowStage1X1Prev = fixdenorm(dryRightLowLpStage1X1);
rightLowStage1X2Prev = fixdenorm(dryRightLowLpStage1X2);
rightLowStage1Y1Prev = fixdenorm(dryRightLowLpStage1Y1);
rightLowStage1Y2Prev = fixdenorm(dryRightLowLpStage1Y2);
rightLowStage1Sum = (rightLpB0Low * dryRightInput) + (rightLpB1Low * rightLowStage1X1Prev) + (rightLpB2Low * rightLowStage1X2Prev);
rightLowStage1Out = (rightLowStage1Sum - (rightLpA1Low * rightLowStage1Y1Prev)) - (rightLpA2Low * rightLowStage1Y2Prev);
dryRightLowLpStage1X2 = rightLowStage1X1Prev;
dryRightLowLpStage1X1 = dryRightInput;
dryRightLowLpStage1Y2 = rightLowStage1Y1Prev;
dryRightLowLpStage1Y1 = rightLowStage1Out;

rightLowStage2X1Prev = fixdenorm(dryRightLowLpStage2X1);
rightLowStage2X2Prev = fixdenorm(dryRightLowLpStage2X2);
rightLowStage2Y1Prev = fixdenorm(dryRightLowLpStage2Y1);
rightLowStage2Y2Prev = fixdenorm(dryRightLowLpStage2Y2);
rightLowStage2Sum = (rightLpB0Low * rightLowStage1Out) + (rightLpB1Low * rightLowStage2X1Prev) + (rightLpB2Low * rightLowStage2X2Prev);
rightLowStage2Out = (rightLowStage2Sum - (rightLpA1Low * rightLowStage2Y1Prev)) - (rightLpA2Low * rightLowStage2Y2Prev);
dryRightLowLpStage2X2 = rightLowStage2X1Prev;
dryRightLowLpStage2X1 = rightLowStage1Out;
dryRightLowLpStage2Y2 = rightLowStage2Y1Prev;
dryRightLowLpStage2Y1 = rightLowStage2Out;

// Cascada rama alta (HP → HP)
rightHighStage1X1Prev = fixdenorm(dryRightLowHpStage1X1);
rightHighStage1X2Prev = fixdenorm(dryRightLowHpStage1X2);
rightHighStage1Y1Prev = fixdenorm(dryRightLowHpStage1Y1);
rightHighStage1Y2Prev = fixdenorm(dryRightLowHpStage1Y2);
rightHighStage1Sum = (rightHpB0Low * dryRightInput) + (rightHpB1Low * rightHighStage1X1Prev) + (rightHpB2Low * rightHighStage1X2Prev);
rightHighStage1Out = (rightHighStage1Sum - (rightHpA1Low * rightHighStage1Y1Prev)) - (rightHpA2Low * rightHighStage1Y2Prev);
dryRightLowHpStage1X2 = rightHighStage1X1Prev;
dryRightLowHpStage1X1 = dryRightInput;
dryRightLowHpStage1Y2 = rightHighStage1Y1Prev;
dryRightLowHpStage1Y1 = rightHighStage1Out;

rightHighStage2X1Prev = fixdenorm(dryRightLowHpStage2X1);
rightHighStage2X2Prev = fixdenorm(dryRightLowHpStage2X2);
rightHighStage2Y1Prev = fixdenorm(dryRightLowHpStage2Y1);
rightHighStage2Y2Prev = fixdenorm(dryRightLowHpStage2Y2);
rightHighStage2Sum = (rightHpB0Low * rightHighStage1Out) + (rightHpB1Low * rightHighStage2X1Prev) + (rightHpB2Low * rightHighStage2X2Prev);
rightHighStage2Out = (rightHighStage2Sum - (rightHpA1Low * rightHighStage2Y1Prev)) - (rightHpA2Low * rightHighStage2Y2Prev);
dryRightLowHpStage2X2 = rightHighStage2X1Prev;
dryRightLowHpStage2X1 = rightHighStage1Out;
dryRightLowHpStage2Y2 = rightHighStage2Y1Prev;
dryRightLowHpStage2Y1 = rightHighStage2Out;

// Compensación all-pass (banda baja)
rightApLowLpStage1X1Prev = fixdenorm(apRightLowLpStage1X1);
rightApLowLpStage1X2Prev = fixdenorm(apRightLowLpStage1X2);
rightApLowLpStage1Y1Prev = fixdenorm(apRightLowLpStage1Y1);
rightApLowLpStage1Y2Prev = fixdenorm(apRightLowLpStage1Y2);
rightApLowLpStage1Sum = (rightLpB0High * rightLowStage2Out) + (rightLpB1High * rightApLowLpStage1X1Prev) + (rightLpB2High * rightApLowLpStage1X2Prev);
rightApLowLpStage1Out = (rightApLowLpStage1Sum - (rightLpA1High * rightApLowLpStage1Y1Prev)) - (rightLpA2High * rightApLowLpStage1Y2Prev);
apRightLowLpStage1X2 = rightApLowLpStage1X1Prev;
apRightLowLpStage1X1 = rightLowStage2Out;
apRightLowLpStage1Y2 = rightApLowLpStage1Y1Prev;
apRightLowLpStage1Y1 = rightApLowLpStage1Out;

rightApLowLpStage2X1Prev = fixdenorm(apRightLowLpStage2X1);
rightApLowLpStage2X2Prev = fixdenorm(apRightLowLpStage2X2);
rightApLowLpStage2Y1Prev = fixdenorm(apRightLowLpStage2Y1);
rightApLowLpStage2Y2Prev = fixdenorm(apRightLowLpStage2Y2);
rightApLowLpStage2Sum = (rightLpB0High * rightApLowLpStage1Out) + (rightLpB1High * rightApLowLpStage2X1Prev) + (rightLpB2High * rightApLowLpStage2X2Prev);
rightApLowLpStage2Out = (rightApLowLpStage2Sum - (rightLpA1High * rightApLowLpStage2Y1Prev)) - (rightLpA2High * rightApLowLpStage2Y2Prev);
apRightLowLpStage2X2 = rightApLowLpStage2X1Prev;
apRightLowLpStage2X1 = rightApLowLpStage1Out;
apRightLowLpStage2Y2 = rightApLowLpStage2Y1Prev;
apRightLowLpStage2Y1 = rightApLowLpStage2Out;

rightApLowHpStage1X1Prev = fixdenorm(apRightLowHpStage1X1);
rightApLowHpStage1X2Prev = fixdenorm(apRightLowHpStage1X2);
rightApLowHpStage1Y1Prev = fixdenorm(apRightLowHpStage1Y1);
rightApLowHpStage1Y2Prev = fixdenorm(apRightLowHpStage1Y2);
rightApLowHpStage1Sum = (rightHpB0High * rightLowStage2Out) + (rightHpB1High * rightApLowHpStage1X1Prev) + (rightHpB2High * rightApLowHpStage1X2Prev);
rightApLowHpStage1Out = (rightApLowHpStage1Sum - (rightHpA1High * rightApLowHpStage1Y1Prev)) - (rightHpA2High * rightApLowHpStage1Y2Prev);
apRightLowHpStage1X2 = rightApLowHpStage1X1Prev;
apRightLowHpStage1X1 = rightLowStage2Out;
apRightLowHpStage1Y2 = rightApLowHpStage1Y1Prev;
apRightLowHpStage1Y1 = rightApLowHpStage1Out;

rightApLowHpStage2X1Prev = fixdenorm(apRightLowHpStage2X1);
rightApLowHpStage2X2Prev = fixdenorm(apRightLowHpStage2X2);
rightApLowHpStage2Y1Prev = fixdenorm(apRightLowHpStage2Y1);
rightApLowHpStage2Y2Prev = fixdenorm(apRightLowHpStage2Y2);
rightApLowHpStage2Sum = (rightHpB0High * rightApLowHpStage1Out) + (rightHpB1High * rightApLowHpStage2X1Prev) + (rightHpB2High * rightApLowHpStage2X2Prev);
rightApLowHpStage2Out = (rightApLowHpStage2Sum - (rightHpA1High * rightApLowHpStage2Y1Prev)) - (rightHpA2High * rightApLowHpStage2Y2Prev);
apRightLowHpStage2X2 = rightApLowHpStage2X1Prev;
apRightLowHpStage2X1 = rightApLowHpStage1Out;
apRightLowHpStage2Y2 = rightApLowHpStage2Y1Prev;
apRightLowHpStage2Y1 = rightApLowHpStage2Out;

dryRightLowBand = rightApLowLpStage2Out + rightApLowHpStage2Out;

// Banda media (LP @ crossover alto)
rightMidStage1X1Prev = fixdenorm(dryRightMidLpStage1X1);
rightMidStage1X2Prev = fixdenorm(dryRightMidLpStage1X2);
rightMidStage1Y1Prev = fixdenorm(dryRightMidLpStage1Y1);
rightMidStage1Y2Prev = fixdenorm(dryRightMidLpStage1Y2);
rightMidStage1Sum = (rightLpB0High * rightHighStage2Out) + (rightLpB1High * rightMidStage1X1Prev) + (rightLpB2High * rightMidStage1X2Prev);
rightMidStage1Out = (rightMidStage1Sum - (rightLpA1High * rightMidStage1Y1Prev)) - (rightLpA2High * rightMidStage1Y2Prev);
dryRightMidLpStage1X2 = rightMidStage1X1Prev;
dryRightMidLpStage1X1 = rightHighStage2Out;
dryRightMidLpStage1Y2 = rightMidStage1Y1Prev;
dryRightMidLpStage1Y1 = rightMidStage1Out;
rightMidStage2X1Prev = fixdenorm(dryRightMidLpStage2X1);
rightMidStage2X2Prev = fixdenorm(dryRightMidLpStage2X2);
rightMidStage2Y1Prev = fixdenorm(dryRightMidLpStage2Y1);
rightMidStage2Y2Prev = fixdenorm(dryRightMidLpStage2Y2);
rightMidStage2Sum = (rightLpB0High * rightMidStage1Out) + (rightLpB1High * rightMidStage2X1Prev) + (rightLpB2High * rightMidStage2X2Prev);
rightMidStage2Out = (rightMidStage2Sum - (rightLpA1High * rightMidStage2Y1Prev)) - (rightLpA2High * rightMidStage2Y2Prev);
dryRightMidLpStage2X2 = rightMidStage2X1Prev;
dryRightMidLpStage2X1 = rightMidStage1Out;
dryRightMidLpStage2Y2 = rightMidStage2Y1Prev;
dryRightMidLpStage2Y1 = rightMidStage2Out;
dryRightMidBand = rightMidStage2Out;

// Banda alta (HP @ crossover alto)
rightHighBandStage1X1Prev = fixdenorm(dryRightHighHpStage1X1);
rightHighBandStage1X2Prev = fixdenorm(dryRightHighHpStage1X2);
rightHighBandStage1Y1Prev = fixdenorm(dryRightHighHpStage1Y1);
rightHighBandStage1Y2Prev = fixdenorm(dryRightHighHpStage1Y2);
rightHighBandStage1Sum = (rightHpB0High * rightHighStage2Out) + (rightHpB1High * rightHighBandStage1X1Prev) + (rightHpB2High * rightHighBandStage1X2Prev);
rightHighBandStage1Out = (rightHighBandStage1Sum - (rightHpA1High * rightHighBandStage1Y1Prev)) - (rightHpA2High * rightHighBandStage1Y2Prev);
dryRightHighHpStage1X2 = rightHighBandStage1X1Prev;
dryRightHighHpStage1X1 = rightHighStage2Out;
dryRightHighHpStage1Y2 = rightHighBandStage1Y1Prev;
dryRightHighHpStage1Y1 = rightHighBandStage1Out;

rightHighBandStage2X1Prev = fixdenorm(dryRightHighHpStage2X1);
rightHighBandStage2X2Prev = fixdenorm(dryRightHighHpStage2X2);
rightHighBandStage2Y1Prev = fixdenorm(dryRightHighHpStage2Y1);
rightHighBandStage2Y2Prev = fixdenorm(dryRightHighHpStage2Y2);
rightHighBandStage2Sum = (rightHpB0High * rightHighBandStage1Out) + (rightHpB1High * rightHighBandStage2X1Prev) + (rightHpB2High * rightHighBandStage2X2Prev);
rightHighBandStage2Out = (rightHighBandStage2Sum - (rightHpA1High * rightHighBandStage2Y1Prev)) - (rightHpA2High * rightHighBandStage2Y2Prev);
dryRightHighHpStage2X2 = rightHighBandStage2X1Prev;
dryRightHighHpStage2X1 = rightHighBandStage1Out;
dryRightHighHpStage2Y2 = rightHighBandStage2Y1Prev;
dryRightHighHpStage2Y1 = rightHighBandStage2Out;
dryRightHighBand = rightHighBandStage2Out;
dryRightSumBands = (dryRightLowBand + dryRightMidBand) + dryRightHighBand;

// Alias para las divisiones en 3 bandas (R) → entradas a LOW/MID/HIGH
lowRIn  = dryRightLowBand;
midRIn  = dryRightMidBand;
highRIn = dryRightHighBand;

// Alias opcional con la suma R
sum3BandR = dryRightSumBands;

// Alinea la reconstrucción dry con la rama de 3 bandas para evitar desbalances de nivel
wetBandSumR = sum3BandR;

// Alias y suavizado del control de la banda LOW
lowBalanceParam = clamp(lowBalance, 0, 1);
lowWidthParam   = clamp(lowBandGainSmoothed, 0, 200);
lowBypassParam  = clamp(setparamInputModeReset, 0, 1);
lowInputParam   = clamp(inputModeSmoothed, 0, 1);
lowUnityGain    = int(1);

lowBypassSlew = slewDefault;
lowBypassSmoothed    = mix(lowBypassParam, lowBypassHistory, lowBypassSlew);
lowBypassHistoryNext = fixdenorm(lowBypassSmoothed);
lowBypassMask = 1 - lowBypassSmoothed;

lowInvertPolarity = int(1); // mantiene el comportamiento original (sin control de inversión)

lowBalanceSlew        = slewDefault;
lowBalanceSmoothed    = mix(lowBalanceParam, lowBalanceHistory, lowBalanceSlew);
lowBalanceHistoryNext = fixdenorm(lowBalanceSmoothed);
//  Ley de balance estéreo (unidad en el centro)
lowBal       = lowBalanceSmoothed;
lowBalT      = (lowBal - 0.5) * 2.0;
lowBalPos    = max(lowBalT, 0);
lowBalNeg    = min(lowBalT, 0);
lowBalGL     = clamp(1 - lowBalPos, 0, 1);
lowBalGR     = clamp(1 + lowBalNeg, 0, 1);

lowWidthSlew        = slewDefault;
lowWidthSmoothed    = mix(lowWidthParam, lowWidthHistory, lowWidthSlew);
lowWidthHistoryNext = fixdenorm(lowWidthSmoothed);
lowWidthControl     = lowWidthSmoothed;

lowInputZero            = int(0);
lowInputSlew            = slewDefault;
lowInputModeSmoothed    = mix(lowInputParam, lowInputModeHistory, lowInputSlew);
lowInputModeHistoryNext = fixdenorm(lowInputModeSmoothed);
lowLeftBlend            = mix(lowLIn, lowInputZero, lowInputModeSmoothed);   // transición suave de la señal dry LOW-L cuando cambia el modo de entrada
lowRightBlend           = mix(lowRIn, lowInputZero, lowInputModeSmoothed);

lowLeftProcessed  = mix(lowInputZero, lowLIn, lowInputModeSmoothed);
lowRightProcessed = mix(lowInputZero, lowRIn, lowInputModeSmoothed);

lowInputSum  = lowLeftProcessed + lowRightProcessed;
mLowRaw      = ((lowInputSum + lowLeftBlend)) * lowUnityGain;
lowInputDiff = lowLeftProcessed - lowRightProcessed;
sLowRaw      = ((lowRightBlend + lowInputDiff)) * lowUnityGain;

// =============================================================================
// PROCESADO DE BANDA — LOW
// =============================================================================
// -----------------------------------------------------------------------------
// [JCBImager][LOW] Control de anchura con normalizacion dependiente del contenido
//   1) Mapeo de potencia constante (M/S)
//   2) Normalizacion RMS por banda (≈50 ms)
// -----------------------------------------------------------------------------
// Usa las constantes compartidas piConstant/epsilonConstant declaradas arriba
//  Ventana RMS de 80 ms para una normalización más estable
lowRmsAlpha = 1 - exp(-1 / ((80 * 0.001) * samplerate));

// M/S antes de aplicar la matriz MS→LR (el factor 0.7071 llega después)

// Ganancias de potencia constante a partir de la anchura (w ∈ [0..2])
// Limita la anchura al 50–150% para evitar aperturas extremas
lowWidthNormalized = clamp(lowWidthControl, 0.0, 2.0);
lowWidthHalf       = lowWidthNormalized * 0.5;

//  Un toque adicional de anchura
lowTheta = lowWidthHalf * (piConstant / 2.55);

//  Usa coseno/seno directamente; la reconstrucción emplea 0.5 (no 0.7071)
lowMonoGain = cos(lowTheta);
lowSideGain = sin(lowTheta);

// Reconstruye L/R limitado en banda desde M/S (antes de las ganancias)
//  Reconstrucción MS→LR previa con factor 0.5 porque M=L+R y S=L−R
lLowPre = (mLowRaw + sLowRaw) * 0.5;
rLowPre = (mLowRaw - sLowRaw) * 0.5;

// Actualiza energías en el dominio L/R y el término cruzado <L*R>
lowLeftEnergyM2       = fixdenorm(lowLeftEnergyM2 + lowRmsAlpha * ((lLowPre * lLowPre) - lowLeftEnergyM2));
lowRightEnergyM2      = fixdenorm(lowRightEnergyM2 + lowRmsAlpha * ((rLowPre * rLowPre) - lowRightEnergyM2));
lowCrossCorrelationM2 = fixdenorm(lowCrossCorrelationM2 + lowRmsAlpha * ((lLowPre * rLowPre) - lowCrossCorrelationM2)); // ahora almacena <L*R>

// (kept for compatibility, not used in normalization anymore)
lowEnergyM2     = fixdenorm(lowEnergyM2 + lowRmsAlpha * ((mLowRaw * mLowRaw) - lowEnergyM2));
lowSideEnergyM2 = fixdenorm(lowSideEnergyM2 + lowRmsAlpha * ((sLowRaw * sLowRaw) - lowSideEnergyM2));

// Coeficientes tras las ganancias MS al volver a L/R
lowMatrixA = 0.5 * (lowMonoGain + lowSideGain);
lowMatrixB = 0.5 * (lowMonoGain - lowSideGain);

// Potencia de entrada y salida prevista, incluyendo correlación
lowInputPower        = lowLeftEnergyM2 + lowRightEnergyM2 + epsilonConstant;
lowOutputPower       = (lowMatrixA*lowMatrixA + lowMatrixB*lowMatrixB) * (lowLeftEnergyM2 + lowRightEnergyM2) + (4.0 * lowMatrixA * lowMatrixB) * lowCrossCorrelationM2 + epsilonConstant;
lowNormalizationGain = sqrt(lowInputPower / lowOutputPower);

// Impulso ligero de nivel cuando la anchura > 1.0 (dependiente del contenido)
lowCorrelationNumerator   = lowCrossCorrelationM2;
lowCorrelationDenominator = sqrt(max(lowLeftEnergyM2 * lowRightEnergyM2, epsilonConstant));
lowCorrelation            = clamp(lowCorrelationNumerator / (lowCorrelationDenominator + epsilonConstant), -1, 1);

// Permite el rango completo 0–2 sin atenuar en exceso la banda
baseGainLow            = dbtoa(4.5);
maxBoostLow            = dbtoa(10.5);
lowMonoGainSafe        = max(lowMonoGain, 0.05);
monoNeedLow            = clamp(1 / lowMonoGainSafe, baseGainLow, maxBoostLow);
lowCorrelationPositive = max(lowCorrelation, 0);
boostAllowanceLow      = baseGainLow + (monoNeedLow - baseGainLow) * lowCorrelationPositive;
lowNormalizationGain   = clamp(lowNormalizationGain, dbtoa(-4.5), boostAllowanceLow);

// Sólo empujar cuando abrimos (> 1.0). lowWidthHalf ∈ [0.25..0.75]
lowLiftBase = max(0, lowWidthHalf - 0.5);   // 0..0.25

// Constante de “empuje” (ajustable 5..7 dB). 6 dB → máx ≈ +1.5 dB
lowLiftSlopeDb = 6.0;
lowLiftDb      = lowLiftSlopeDb * lowLiftBase * (1 - lowCorrelation);

// Aplicar después de la normalización base
lowNormalizationGain = lowNormalizationGain * dbtoa(lowLiftDb);
// Alias solo para facilitar la lectura
lowNormGain   = lowNormalizationGain;
lowCorr       = lowCorrelation;
lowWidthCtrl  = lowWidthNormalized;
// Genera leve bump de 0.4 en la banda grave, si molesta quitar de momento lo mantengo

// Aplica la matriz MS→LR con las ganancias y la normalización
//  Matriz MS→LR cuando M=L+R y S=L−R
lowMonoHalf      = mLowRaw * 0.5;
lowSideHalf      = sLowRaw * 0.5;
lowMonoScaled    = lowMonoHalf * (lowMonoGain * lowNormGain);
lowSideScaled    = lowSideHalf * (lowSideGain * lowNormGain);
lowSidePolarity  = lowSideScaled * lowInvertPolarity;
lowRightPreWidth = lowMonoScaled - lowSidePolarity;
wetLowR          = lowRightPreWidth;
lowLeftPreWidth  = lowMonoScaled + lowSidePolarity;
wetLowL          = lowLeftPreWidth;
lowLeftBalanced  = wetLowL * lowBalGL;
lowLeftWithGain  = lowLeftBalanced * lowUnityGain;
lowLeftMixed     = mix(lowLIn, lowLeftWithGain, lowBypassMask);

// [LOW] compuerta mute suavizada
muteLowSlew     = slewDefault;
muteLowSmoothed = mix(muteLow, muteLowHistory, muteLowSlew);
muteLowHistory  = fixdenorm(muteLowSmoothed);
lowMuteGateRaw  = 1 - clamp(muteLowSmoothed, 0, 1);
muteLowGate     = lowMuteGateRaw;

// aplicar a LOW L/R
lowLeftMixed     = lowLeftMixed * muteLowGate;
lowRightBalanced = wetLowR * lowBalGR;  // ganancia derecha
lowRightWithGain = lowRightBalanced * lowUnityGain;
lowRightMixed    = mix(lowRIn, lowRightWithGain, lowBypassMask);

// [LOW] aplicar a LOW R
lowRightMixed       = lowRightMixed * muteLowGate;
wetLowRightPostSolo = mix(lowRightMixed, soloZero, soloMaskLow);
wetLowLeftPostSolo  = mix(lowLeftMixed, soloZero, soloMaskLow);

// Salidas wet de banda (tras solo/mute) — LOW
wetLowRPost = wetLowRightPostSolo;
wetLowLPost = wetLowLeftPostSolo;

// Alias y suavizado del control de la banda MID
midBandGainDbParam   = clamp(0, -96, 12);
midSideGainDbParam   = clamp(0, -96, 12);
midMakeupDbParam     = clamp(0, -24, 6);
midInvertParam       = clamp(0, 0, 1);
midBalanceParam      = clamp(midBalanceSmoothed, 0, 1);
midWidthParam        = clamp(midBandGainSmoothed, 0, 200);
midBypassParam       = clamp(setparamLowGainReset, 0, 1);
midInputParam        = clamp(inputModeSmoothed, 0, 1);

midBypassSlew        = slewDefault;
midBypassSmoothed    = mix(midBypassParam, midBypassHistory, midBypassSlew);
midBypassHistoryNext = fixdenorm(midBypassSmoothed);
midBypassMask        = 1 - midBypassSmoothed;

midMakeupSlew        = slewDefault;
midMakeupDbSmoothed  = mix(midMakeupDbParam, midMakeupHistory, midMakeupSlew);
midMakeupHistoryNext = fixdenorm(midMakeupDbSmoothed);
midMakeupLinear      = dbtoa(midMakeupDbSmoothed);

midBalanceSlew                = slewDefault;
midBalanceSmoothed            = mix(midBalanceParam, midBalanceInternalHistory, midBalanceSlew);
midBalanceInternalHistoryNext = fixdenorm(midBalanceSmoothed);

//  Ley de balance estéreo (unidad en el centro) para MID
midBal    = midBalanceSmoothed;
midBalT   = (midBal - 0.5) * 2.0;
midBalPos = max(midBalT, 0);
midBalNeg = min(midBalT, 0);
midBalGL  = clamp(1 - midBalPos, 0, 1);
midBalGR  = clamp(1 + midBalNeg, 0, 1);

midWidthSlew            = slewDefault;
midWidthSmoothed        = mix(midWidthParam, midWidthHistory, midWidthSlew);
midWidthHistoryNext     = fixdenorm(midWidthSmoothed);
midWidthParameter       = midWidthSmoothed;
midInputZero            = int(0);
midInputSlew            = slewDefault;
midInputModeSmoothed    = mix(midInputParam, midInputModeHistory, midInputSlew);
midInputModeHistoryNext = fixdenorm(midInputModeSmoothed);
midLeftBypassBlend      = mix(midLIn, midInputZero, midInputModeSmoothed);
midRightBypassBlend     = mix(midRIn, midInputZero, midInputModeSmoothed);

midLeftProcessed  = mix(midInputZero, midLIn, midInputModeSmoothed);
midRightProcessed = mix(midInputZero, midRIn, midInputModeSmoothed);

midInputSum  = midLeftProcessed + midRightProcessed;
midInputDiff = midLeftProcessed - midRightProcessed;

midBandGainLinearTarget        = dbtoa(midBandGainDbParam);
midBandGainSlew                = slewDefault;
midBandGainSmoothed            = mix(midBandGainLinearTarget, midBandGainHistoryInternal, midBandGainSlew);
midBandGainHistoryInternalNext = fixdenorm(midBandGainSmoothed);
midBandGainLinear              = midBandGainSmoothed;
mMidRaw                        = (midInputSum + midLeftBypassBlend) * midBandGainLinear;

midSideGainLinearTarget = dbtoa(midSideGainDbParam);
midSideGainSlew         = slewDefault;
midSideGainSmoothed     = mix(midSideGainLinearTarget, midSideGainHistory, midSideGainSlew);
midSideGainHistoryNext  = fixdenorm(midSideGainSmoothed);
midSideGainLinear       = midSideGainSmoothed;
sMidRaw                 = (midRightBypassBlend + midInputDiff) * midSideGainLinear;
invertPositive          = int(1);
invertNegative          = int(-1);
midInvertSwitch         = midInvertParam ? invertPositive : invertNegative;
midInvertTarget         = midInvertSwitch * -1;
midInvertSmoothed       = mix(midInvertTarget, midInvertHistory, 0);
midInvertHistoryNext    = fixdenorm(midInvertSmoothed);
midInvertPolarity       = midInvertSmoothed;
// =============================================================================
// PROCESADO DE BANDA — MID
// =============================================================================
// -----------------------------------------------------------------------------
// [JCBImager][MID] Control de anchura con normalizacion dependiente del contenido
// -----------------------------------------------------------------------------
// Las constantes piConstant/epsilonConstant también aplican aquí
//  Ventana RMS de 80 ms
midRmsAlpha = 1 - exp(-1 / ((80 * 0.001) * samplerate));

// Limita la anchura al 50–150%
midWidthNormalized = clamp(midWidthParameter, 0.0, 2.0);
midWidthHalf       = midWidthNormalized * 0.5;

//  Un toque adicional de anchura
midTheta = midWidthHalf * (piConstant / 2.55);

//  Usa cos/sin de forma directa; la matriz LR emplea 0.5
midMonoGain = cos(midTheta);
midSideGain = sin(midTheta);

// Reconstruye L/R limitado en banda desde M/S (antes de las ganancias)
//  Reconstrucción MS→LR previa con factor 0.5 porque M=L+R y S=L−R
lMidPre = (mMidRaw + sMidRaw) * 0.5;
rMidPre = (mMidRaw - sMidRaw) * 0.5;

midLeftEnergyM2       = fixdenorm(midLeftEnergyM2 + midRmsAlpha * ((lMidPre * lMidPre) - midLeftEnergyM2));
midRightEnergyM2      = fixdenorm(midRightEnergyM2 + midRmsAlpha * ((rMidPre * rMidPre) - midRightEnergyM2));
midCrossCorrelationM2 = fixdenorm(midCrossCorrelationM2 + midRmsAlpha * ((lMidPre * rMidPre) - midCrossCorrelationM2)); // ahora almacena <L*R>

// (se mantiene por compatibilidad, ya no se usa en la normalización)
midEnergyM2     = fixdenorm(midEnergyM2 + midRmsAlpha * ((mMidRaw * mMidRaw) - midEnergyM2));
midSideEnergyM2 = fixdenorm(midSideEnergyM2 + midRmsAlpha * ((sMidRaw * sMidRaw) - midSideEnergyM2));

midMatrixA           = 0.5 * (midMonoGain + midSideGain);
midMatrixB           = 0.5 * (midMonoGain - midSideGain);
midInputPower        = midLeftEnergyM2 + midRightEnergyM2 + epsilonConstant;
midOutputPower       = (midMatrixA*midMatrixA + midMatrixB*midMatrixB) * (midLeftEnergyM2 + midRightEnergyM2) + (4.0 * midMatrixA * midMatrixB) * midCrossCorrelationM2 + epsilonConstant;
midNormalizationGain = sqrt(midInputPower / midOutputPower);

midCorrelationNumerator   = midCrossCorrelationM2;
midCorrelationDenominator = sqrt(max(midLeftEnergyM2 * midRightEnergyM2, epsilonConstant));
midCorrelation            = clamp(midCorrelationNumerator / (midCorrelationDenominator + epsilonConstant), -1, 1); //

// Headroom adaptativo mantiene el nivel con material muy correlacionado en anchuras extremas
baseGainMid            = dbtoa(4.5);
maxBoostMid            = dbtoa(10.5);
midMonoGainSafe        = max(midMonoGain, 0.05);
monoNeedMid            = clamp(1 / midMonoGainSafe, baseGainMid, maxBoostMid);
midCorrelationPositive = max(midCorrelation, 0);
boostAllowanceMid      = baseGainMid + (monoNeedMid - baseGainMid) * midCorrelationPositive;
midNormalizationGain   = clamp(midNormalizationGain, dbtoa(-4.5), boostAllowanceMid);
midLiftBase            = max(0, midWidthHalf - 0.5);
midLiftSlopeDb         = 6.0;
midLiftDb              = midLiftSlopeDb * midLiftBase * (1 - midCorrelation);
midNormalizationGain   = midNormalizationGain * dbtoa(midLiftDb);

// Alias solo para facilitar la lectura
midNormGain   = midNormalizationGain;
midCorr       = midCorrelation;
midWidthCtrl  = midWidthNormalized;

midMonoHalf          = mMidRaw * 0.5;
midSideHalf          = sMidRaw * 0.5;
midMonoScaled        = midMonoHalf * (midMonoGain * midNormGain);
midSideScaled        = midSideHalf * (midSideGain * midNormGain);
midSidePolarity      = midSideScaled * midInvertPolarity;
midRightPreWidth     = midMonoScaled - midSidePolarity;
wetMidR              = midRightPreWidth;
midLeftPreWidth      = midMonoScaled + midSidePolarity;
wetMidL              = midLeftPreWidth;
midRightBalanced     = wetMidR * midBalGR;  // ganancia derecha
midRightWithBandGain = midRightBalanced * midMakeupLinear;
midRightMixed        = mix(midRIn, midRightWithBandGain, midBypassMask);

// [MID]
muteMidSlew     = slewDefault;
muteMidSmoothed = mix(muteMid, muteMidHistory, muteMidSlew);
muteMidHistory  = fixdenorm(muteMidSmoothed);
midMuteGateRaw  = 1 - clamp(muteMidSmoothed, 0, 1);
muteMidGate     = midMuteGateRaw;

// aplicar a MID R
midRightMixed       = midRightMixed * muteMidGate;
midLeftBalanced     = wetMidL * midBalGL;  // ganancia izquierda
midLeftWithBandGain = midLeftBalanced * midMakeupLinear;
midLeftMixed        = mix(midLIn, midLeftWithBandGain, midBypassMask);

// [MID] aplicar a MID L
midLeftMixed        = midLeftMixed * muteMidGate;
wetMidRightPostSolo = mix(midRightMixed, soloMidZero, soloMaskMid);
wetMidLeftPostSolo  = mix(midLeftMixed, soloMidZero, soloMaskMid);

// Salidas wet de banda (tras solo/mute) — MID
wetMidRPost = wetMidRightPostSolo;
wetMidLPost = wetMidLeftPostSolo;

// Alias y suavizado del control de la banda HIGH
highSideGainDbParam  = clamp(0, -96, 12);
highBandGainDbParam  = clamp(0, -96, 12);
highInvertParam      = clamp(0, 0, 1);
highMakeupDbParam    = clamp(0, -24, 6);
highBalanceParam     = clamp(highBalanceSmoothed, 0, 1);
highWidthParam       = clamp(highBandGainSmoothed, 0, 200);
highBypassParam      = clamp(setparamMidGainReset, 0, 1);
highInputParam       = clamp(inputModeSmoothed, 0, 1);

highBypassSlew = slewDefault;
highBypassSmoothed    = mix(highBypassParam, highBypassHistory, highBypassSlew);
highBypassHistoryNext = fixdenorm(highBypassSmoothed);
highBypassMask        = 1 - highBypassSmoothed;

highMakeupSlew        = slewDefault;
highMakeupDbSmoothed  = mix(highMakeupDbParam, highMakeupHistory, highMakeupSlew);
highMakeupHistoryNext = fixdenorm(highMakeupDbSmoothed);
highMakeupLinear      = dbtoa(highMakeupDbSmoothed);

highBalanceSlew                = slewDefault;
highBalanceSmoothed            = mix(highBalanceParam, highBalanceHistoryInternal, highBalanceSlew);
highBalanceHistoryInternalNext = fixdenorm(highBalanceSmoothed);

//  Ley de balance estéreo (unidad en el centro) para HIGH
highBal  = highBalanceSmoothed;
highBalT      = (highBal - 0.5) * 2.0;
highBalPos    = max(highBalT, 0);
highBalNeg    = min(highBalT, 0);
highBalGL     = clamp(1 - highBalPos, 0, 1);
highBalGR     = clamp(1 + highBalNeg, 0, 1);

highWidthSlew        = slewDefault;
highWidthSmoothed    = mix(highWidthParam, highWidthHistory, highWidthSlew);
highWidthHistoryNext = fixdenorm(highWidthSmoothed);

highWidthParameter = highWidthSmoothed;
highInputZero            = int(0);
highInputSlew            = slewDefault;
highInputModeSmoothed    = mix(highInputParam, highInputModeHistory, highInputSlew);
highInputModeHistoryNext = fixdenorm(highInputModeSmoothed);
highLeftBypassBlend      = mix(highLIn, highInputZero, highInputModeSmoothed);
highRightBypassBlend     = mix(highRIn, highInputZero, highInputModeSmoothed);

highLeftProcessed  = mix(highInputZero, highLIn, highInputModeSmoothed);
highRightProcessed = mix(highInputZero, highRIn, highInputModeSmoothed);

highInputSum  = highLeftProcessed + highRightProcessed;
highInputDiff = highLeftProcessed - highRightProcessed;

highBandGainLinearTarget        = dbtoa(highBandGainDbParam);
highBandGainSlew                = slewDefault;
highBandGainSmoothed            = mix(highBandGainLinearTarget, highBandGainHistoryInternal, highBandGainSlew);
highBandGainHistoryInternalNext = fixdenorm(highBandGainSmoothed);
highBandGainLinear              = highBandGainSmoothed;
mHighRaw                        = (highInputSum + highLeftBypassBlend) * highBandGainLinear;

highSideGainLinearTarget = dbtoa(highSideGainDbParam);
highSideGainSlew         = slewDefault;
highSideGainSmoothed     = mix(highSideGainLinearTarget, highSideGainHistory, highSideGainSlew);
highSideGainHistoryNext  = fixdenorm(highSideGainSmoothed);
highSideGainLinear       = highSideGainSmoothed;
sHighRaw                 = (highRightBypassBlend + highInputDiff) * highSideGainLinear;
invertPositiveHigh       = int(1);
invertNegativeHigh       = int(-1);
highInvertSwitch         = highInvertParam ? invertPositiveHigh : invertNegativeHigh;
highInvertTarget         = highInvertSwitch * -1;
highInvertSmoothed       = mix(highInvertTarget, highInvertHistory, 0);
highInvertHistoryNext    = fixdenorm(highInvertSmoothed);
highInvertPolarity       = highInvertSmoothed;

// =============================================================================
// PROCESADO DE BANDA — HIGH
// =============================================================================
// -----------------------------------------------------------------------------
// [JCBImager][HIGH] Control de anchura con normalizacion dependiente del contenido
// -----------------------------------------------------------------------------
//  Ventana RMS de 80 ms
highRmsAlpha = 1 - exp(-1 / ((80 * 0.001) * samplerate));

// Limita la anchura al 50–150%
highWidthNormalized  = clamp(highWidthParameter, 0.0, 2.0);
highWidthHalf        = highWidthNormalized * 0.5;

//  Un toque adicional de anchura
highTheta = highWidthHalf * (piConstant / 2.55);

highMonoGain = cos(highTheta);
highSideGain = sin(highTheta);

// Reconstruye L/R limitado en banda desde M/S (antes de las ganancias)
lHighPre = (mHighRaw + sHighRaw) * 0.5;
rHighPre = (mHighRaw - sHighRaw) * 0.5;

// Actualiza energías en el dominio L/R y el término cruzado <L*R>
highLeftEnergyM2       = fixdenorm(highLeftEnergyM2 + highRmsAlpha * ((lHighPre * lHighPre) - highLeftEnergyM2));
highRightEnergyM2      = fixdenorm(highRightEnergyM2 + highRmsAlpha * ((rHighPre * rHighPre) - highRightEnergyM2));
highCrossCorrelationM2 = fixdenorm(highCrossCorrelationM2 + highRmsAlpha * ((lHighPre * rHighPre) - highCrossCorrelationM2)); // ahora almacena <L*R>

// (se mantiene por compatibilidad, ya no se usa en la normalización)
highEnergyM2     = fixdenorm(highEnergyM2 + highRmsAlpha * ((mHighRaw * mHighRaw) - highEnergyM2));
highSideEnergyM2 = fixdenorm(highSideEnergyM2 + highRmsAlpha * ((sHighRaw * sHighRaw) - highSideEnergyM2));

highMatrixA           = 0.5 * (highMonoGain + highSideGain);
highMatrixB           = 0.5 * (highMonoGain - highSideGain);
highInputPower        = highLeftEnergyM2 + highRightEnergyM2 + epsilonConstant;
highOutputPower       = (highMatrixA*highMatrixA + highMatrixB*highMatrixB) * (highLeftEnergyM2 + highRightEnergyM2) + (4.0 * highMatrixA * highMatrixB) * highCrossCorrelationM2 + epsilonConstant;
highNormalizationGain = sqrt(highInputPower / highOutputPower);

highCorrelationNumerator   = highCrossCorrelationM2;
highCorrelationDenominator = sqrt(max(highLeftEnergyM2 * highRightEnergyM2, epsilonConstant));
highCorrelation            = clamp(highCorrelationNumerator / (highCorrelationDenominator + epsilonConstant), -1, 1);

// Headroom adaptativo replica el comportamiento LOW/MID con material correlacionado
baseGainHigh               = dbtoa(4.5);
maxBoostHigh               = dbtoa(10.5);
highMonoGainSafe           = max(highMonoGain, 0.05);
monoNeedHigh               = clamp(1 / highMonoGainSafe, baseGainHigh, maxBoostHigh);
highCorrelationPositive    = max(highCorrelation, 0);
boostAllowanceHigh         = baseGainHigh + (monoNeedHigh - baseGainHigh) * highCorrelationPositive;
highNormalizationGain      = clamp(highNormalizationGain, dbtoa(-4.5), boostAllowanceHigh);

highLiftBase          = max(0, highWidthHalf - 0.5);
highLiftSlopeDb       = 6.0;
highLiftDb            = highLiftSlopeDb * highLiftBase * (1 - highCorrelation);
highNormalizationGain = highNormalizationGain * dbtoa(highLiftDb);

// Alias solo para facilitar la lectura
highNormGain   = highNormalizationGain;
highCorr       = highCorrelation;
highWidthCtrl  = highWidthNormalized;

highMonoHalf         = mHighRaw * 0.5;
highSideHalf         = sHighRaw * 0.5;
highMonoScaled       = highMonoHalf * (highMonoGain * highNormGain);
highSideScaled       = highSideHalf * (highSideGain * highNormGain);
highSidePolarity     = highSideScaled * highInvertPolarity;
highRightPreWidth    = highMonoScaled - highSidePolarity;
wetHighR             = highRightPreWidth;
highLeftPreWidth     = highMonoScaled + highSidePolarity;
wetHighL             = highLeftPreWidth;
highLeftBalanced     = wetHighL * highBalGL;  // ganancia izquierda
highLeftWithBandGain = highLeftBalanced * highMakeupLinear;
highLeftMixed        = mix(highLIn, highLeftWithBandGain, highBypassMask);

// [HIGH]
muteHighSlew     = slewDefault;
muteHighSmoothed = mix(muteHigh, muteHighHistory, muteHighSlew);
muteHighHistory  = fixdenorm(muteHighSmoothed);
highMuteGateRaw  = 1 - clamp(muteHighSmoothed, 0, 1);
muteHighGate     = highMuteGateRaw;

// aplicar a HIGH L
highLeftMixed         = highLeftMixed * muteHighGate;
highRightBalanced     = wetHighR * highBalGR;  // ganancia derecha
highRightWithBandGain = highRightBalanced * highMakeupLinear;
highRightMixed        = mix(highRIn, highRightWithBandGain, highBypassMask);

// [HIGH] aplicar a HIGH R
highRightMixed = highRightMixed * muteHighGate;

// Salidas wet de banda (tras solo/mute) — HIGH
wetHighRPost = highRightMixed; // R tras gestionar solo/mute
wetHighLPost = highLeftMixed; // L tras gestionar solo/mute

// Alias (solo rama wet)
wetTrimL    = trimLeftNext;
wetTrimR    = trimRightNext;
wetMakeupL  = makeupLeftNext;
wetMakeupR  = makeupRightNext;

// =============================================================================
// ALIAS PARA LEGIBILIDAD EN LA ETAPA DE SALIDA
// =============================================================================
// Ramas dry y máscaras de control
dryInL     = in1;
dryInR     = in2;
dryWetMix  = dryWetControl;  // control dry/wet suavizado

// =============================================================================
// MEZCLA FINAL (MAKEUP SOLO WET → BYPASS → DRY/WET)
// =============================================================================
wetHighRightPostSolo = mix(highRightMixed, soloHighZero, soloMaskHigh);

// Sumas wet por lado (tras solo/mute) para facilitar la lectura
wetRightTotal   = (wetHighRightPostSolo + wetMidRightPostSolo) + wetLowRightPostSolo; // high + mid + low (canal derecho)
wetRightBlended = mix(wetBandSumR, wetRightTotal * wetMakeupR, dryWetMix);
wetOutR         = wetRightBlended;
finalRightMix   = mix(dryInR, wetRightBlended, bypassMask);
finalOutR       = finalRightMix;
out2            = finalOutR;

wetHighLeftPostSolo = mix(highLeftMixed, soloHighZero, soloMaskHigh);
wetLeftTotal    = (wetHighLeftPostSolo + wetMidLeftPostSolo) + wetLowLeftPostSolo; // high + mid + low (canal izquierdo)
wetLeftBlended  = mix(wetBandSumL, wetLeftTotal * wetMakeupL, dryWetMix);
wetOutL         = wetLeftBlended;
finalLeftMix    = mix(dryInL, wetLeftBlended, bypassMask);
finalOutL       = finalLeftMix;
out1            = finalOutL;

// -----------------------------------------------------------------------------
// ACTUALIZACION DE HISTORIALES
// -----------------------------------------------------------------------------
dryWetHistory        = dryWetHistoryNext;
bypassHistory        = bypassHistoryNext;
soloMidHistory       = soloMidHistoryNext;
soloHighHistory      = soloHighHistoryNext;
soloLowHistory       = soloLowHistoryNext;
inputModeHistory     = inputModeHistoryNext;
lowBandGainHistory   = lowBandGainHistoryNext;
midBandGainHistory   = midBandGainHistoryNext;
midBalanceHistory    = midBalanceHistoryNext;
highBandGainHistory  = highBandGainHistoryNext;
highBalanceHistory   = highBalanceHistoryNext;
highCrossoverHistory = highCrossoverHistoryNext;
lowCrossoverHistory  = lowCrossoverHistoryNext;

highMakeupHistory           = highMakeupHistoryNext;
highBalanceHistoryInternal  = highBalanceHistoryInternalNext;
highWidthHistory            = highWidthHistoryNext;
highInputModeHistory        = highInputModeHistoryNext;
highBandGainHistoryInternal = highBandGainHistoryInternalNext;
highSideGainHistory         = highSideGainHistoryNext;
highInvertHistory           = highInvertHistoryNext;
highBypassHistory           = highBypassHistoryNext;
midMakeupHistory            = midMakeupHistoryNext;
midBalanceInternalHistory   = midBalanceInternalHistoryNext;
midWidthHistory             = midWidthHistoryNext;
midInputModeHistory         = midInputModeHistoryNext;
midBandGainHistoryInternal  = midBandGainHistoryInternalNext;
midSideGainHistory          = midSideGainHistoryNext;
midInvertHistory            = midInvertHistoryNext;
midBypassHistory            = midBypassHistoryNext;
lowBalanceHistory           = lowBalanceHistoryNext;
lowWidthHistory             = lowWidthHistoryNext;
lowInputModeHistory         = lowInputModeHistoryNext;
lowBypassHistory            = lowBypassHistoryNext;

// Actualizaciones de trim
trimLeftHistory   = trimLeftNext;
trimRightHistory  = trimRightNext;
trimSharedHistory = trimSharedNext;

// Actualizaciones de makeup
makeupLeftHistory   = makeupLeftNext;
makeupRightHistory  = makeupRightNext;
makeupSharedHistory = makeupSharedNext;
