// Crossover LR4 de 3 bandas con compensación de fase correcta
// out1: Low (20-250Hz)
// out2: Mid (250-5kHz)
// out3: High (5k-20kHz)
// out4: Suma de las 3 bandas (debe hacer null test con entrada)

// ===== DECLARACIONES =====
Param freq_low(250, min=20, max=1000, default=250);
Param freq_high(5000, min=1000, max=20000, default=5000);

// Estados para los 8 biquads del crossover principal
History l1_x1(0), l1_x2(0), l1_y1(0), l1_y2(0); // Low stage 1
History l2_x1(0), l2_x2(0), l2_y1(0), l2_y2(0); // Low stage 2
History h1_x1(0), h1_x2(0), h1_y1(0), h1_y2(0); // Rest HP stage 1
History h2_x1(0), h2_x2(0), h2_y1(0), h2_y2(0); // Rest HP stage 2
History m1_x1(0), m1_x2(0), m1_y1(0), m1_y2(0); // Mid LP stage 1
History m2_x1(0), m2_x2(0), m2_y1(0), m2_y2(0); // Mid LP stage 2
History u1_x1(0), u1_x2(0), u1_y1(0), u1_y2(0); // High HP stage 1
History u2_x1(0), u2_x2(0), u2_y1(0), u2_y2(0); // High HP stage 2

// Estados para all-pass de compensación en la banda LOW
History ap_low_lp1_x1(0), ap_low_lp1_x2(0), ap_low_lp1_y1(0), ap_low_lp1_y2(0);
History ap_low_lp2_x1(0), ap_low_lp2_x2(0), ap_low_lp2_y1(0), ap_low_lp2_y2(0);
History ap_low_hp1_x1(0), ap_low_hp1_x2(0), ap_low_hp1_y1(0), ap_low_hp1_y2(0);
History ap_low_hp2_x1(0), ap_low_hp2_x2(0), ap_low_hp2_y1(0), ap_low_hp2_y2(0);

// ===== PROCESO =====
x = in1;

// Proteger frecuencias
sr = samplerate;
loF = max(10, min(freq_low, 0.45 * sr));
hiFr = max(10, min(freq_high, 0.45 * sr));
hiF = max(hiFr, loF + 1);

// Constantes
QBW = 0.7071067811865476; // sqrt(2)/2 para Butterworth

// === Coeficientes Butterworth @ freq_low ===
w0_lo = TWOPI * loF / sr;
cos_lo = cos(w0_lo);
sin_lo = sin(w0_lo);
alpha_lo = sin_lo / (2 * QBW);
a0_lo = 1 + alpha_lo;
a1_lo = -2 * cos_lo;
a2_lo = 1 - alpha_lo;

// LP @ freq_low (normalizado)
lp_b0_l = ((1 - cos_lo) * 0.5) / a0_lo;
lp_b1_l = (1 - cos_lo) / a0_lo;
lp_b2_l = lp_b0_l;
lp_a1_l = a1_lo / a0_lo;
lp_a2_l = a2_lo / a0_lo;

// HP @ freq_low (normalizado)
hp_b0_l = ((1 + cos_lo) * 0.5) / a0_lo;
hp_b1_l = -(1 + cos_lo) / a0_lo;
hp_b2_l = hp_b0_l;
hp_a1_l = lp_a1_l;
hp_a2_l = lp_a2_l;

// === Coeficientes Butterworth @ freq_high ===
w0_hi = TWOPI * hiF / sr;
cos_hi = cos(w0_hi);
sin_hi = sin(w0_hi);
alpha_hi = sin_hi / (2 * QBW);
a0_hi = 1 + alpha_hi;
a1_hi = -2 * cos_hi;
a2_hi = 1 - alpha_hi;

// LP @ freq_high (normalizado)
lp_b0_h = ((1 - cos_hi) * 0.5) / a0_hi;
lp_b1_h = (1 - cos_hi) / a0_hi;
lp_b2_h = lp_b0_h;
lp_a1_h = a1_hi / a0_hi;
lp_a2_h = a2_hi / a0_hi;

// HP @ freq_high (normalizado)
hp_b0_h = ((1 + cos_hi) * 0.5) / a0_hi;
hp_b1_h = -(1 + cos_hi) / a0_hi;
hp_b2_h = hp_b0_h;
hp_a1_h = lp_a1_h;
hp_a2_h = lp_a2_h;

// ===== PRIMER CORTE @ freq_low: low (LP) y rest (HP) =====

// LP Stage 1 para LOW
l1_x1p = l1_x1; l1_x2p = l1_x2; l1_y1p = l1_y1; l1_y2p = l1_y2;
low_s1 = lp_b0_l*x + lp_b1_l*l1_x1p + lp_b2_l*l1_x2p - lp_a1_l*l1_y1p - lp_a2_l*l1_y2p;
l1_x2 = l1_x1p; l1_x1 = x; l1_y2 = l1_y1p; l1_y1 = low_s1;

// LP Stage 2 para LOW
l2_x1p = l2_x1; l2_x2p = l2_x2; l2_y1p = l2_y1; l2_y2p = l2_y2;
low_raw = lp_b0_l*low_s1 + lp_b1_l*l2_x1p + lp_b2_l*l2_x2p - lp_a1_l*l2_y1p - lp_a2_l*l2_y2p;
l2_x2 = l2_x1p; l2_x1 = low_s1; l2_y2 = l2_y1p; l2_y1 = low_raw;

// HP Stage 1 para REST
h1_x1p = h1_x1; h1_x2p = h1_x2; h1_y1p = h1_y1; h1_y2p = h1_y2;
rest_s1 = hp_b0_l*x + hp_b1_l*h1_x1p + hp_b2_l*h1_x2p - hp_a1_l*h1_y1p - hp_a2_l*h1_y2p;
h1_x2 = h1_x1p; h1_x1 = x; h1_y2 = h1_y1p; h1_y1 = rest_s1;

// HP Stage 2 para REST
h2_x1p = h2_x1; h2_x2p = h2_x2; h2_y1p = h2_y1; h2_y2p = h2_y2;
rest = hp_b0_l*rest_s1 + hp_b1_l*h2_x1p + hp_b2_l*h2_x2p - hp_a1_l*h2_y1p - hp_a2_l*h2_y2p;
h2_x2 = h2_x1p; h2_x1 = rest_s1; h2_y2 = h2_y1p; h2_y1 = rest;

// ===== COMPENSACIÓN ALL-PASS para LOW =====
// Aplicamos un all-pass LP+HP @ freq_high a la señal LOW para igualar el delay

// All-pass LP stage 1 sobre low_raw
ap_low_lp1_x1p = ap_low_lp1_x1; ap_low_lp1_x2p = ap_low_lp1_x2;
ap_low_lp1_y1p = ap_low_lp1_y1; ap_low_lp1_y2p = ap_low_lp1_y2;
ap_low_lp_s1 = lp_b0_h*low_raw + lp_b1_h*ap_low_lp1_x1p + lp_b2_h*ap_low_lp1_x2p
               - lp_a1_h*ap_low_lp1_y1p - lp_a2_h*ap_low_lp1_y2p;
ap_low_lp1_x2 = ap_low_lp1_x1p; ap_low_lp1_x1 = low_raw;
ap_low_lp1_y2 = ap_low_lp1_y1p; ap_low_lp1_y1 = ap_low_lp_s1;

// All-pass LP stage 2
ap_low_lp2_x1p = ap_low_lp2_x1; ap_low_lp2_x2p = ap_low_lp2_x2;
ap_low_lp2_y1p = ap_low_lp2_y1; ap_low_lp2_y2p = ap_low_lp2_y2;
ap_low_lp = lp_b0_h*ap_low_lp_s1 + lp_b1_h*ap_low_lp2_x1p + lp_b2_h*ap_low_lp2_x2p
            - lp_a1_h*ap_low_lp2_y1p - lp_a2_h*ap_low_lp2_y2p;
ap_low_lp2_x2 = ap_low_lp2_x1p; ap_low_lp2_x1 = ap_low_lp_s1;
ap_low_lp2_y2 = ap_low_lp2_y1p; ap_low_lp2_y1 = ap_low_lp;

// All-pass HP stage 1 sobre low_raw
ap_low_hp1_x1p = ap_low_hp1_x1; ap_low_hp1_x2p = ap_low_hp1_x2;
ap_low_hp1_y1p = ap_low_hp1_y1; ap_low_hp1_y2p = ap_low_hp1_y2;
ap_low_hp_s1 = hp_b0_h*low_raw + hp_b1_h*ap_low_hp1_x1p + hp_b2_h*ap_low_hp1_x2p
               - hp_a1_h*ap_low_hp1_y1p - hp_a2_h*ap_low_hp1_y2p;
ap_low_hp1_x2 = ap_low_hp1_x1p; ap_low_hp1_x1 = low_raw;
ap_low_hp1_y2 = ap_low_hp1_y1p; ap_low_hp1_y1 = ap_low_hp_s1;

// All-pass HP stage 2
ap_low_hp2_x1p = ap_low_hp2_x1; ap_low_hp2_x2p = ap_low_hp2_x2;
ap_low_hp2_y1p = ap_low_hp2_y1; ap_low_hp2_y2p = ap_low_hp2_y2;
ap_low_hp = hp_b0_h*ap_low_hp_s1 + hp_b1_h*ap_low_hp2_x1p + hp_b2_h*ap_low_hp2_x2p
            - hp_a1_h*ap_low_hp2_y1p - hp_a2_h*ap_low_hp2_y2p;
ap_low_hp2_x2 = ap_low_hp2_x1p; ap_low_hp2_x1 = ap_low_hp_s1;
ap_low_hp2_y2 = ap_low_hp2_y1p; ap_low_hp2_y1 = ap_low_hp;

// LOW compensado (all-pass reconstruye la señal con el mismo delay que mid/high)
low = ap_low_lp + ap_low_hp;

// ===== SEGUNDO CORTE @ freq_high sobre REST: mid (LP) y high (HP) =====

// LP Stage 1 para MID
m1_x1p = m1_x1; m1_x2p = m1_x2; m1_y1p = m1_y1; m1_y2p = m1_y2;
mid_s1 = lp_b0_h*rest + lp_b1_h*m1_x1p + lp_b2_h*m1_x2p - lp_a1_h*m1_y1p - lp_a2_h*m1_y2p;
m1_x2 = m1_x1p; m1_x1 = rest; m1_y2 = m1_y1p; m1_y1 = mid_s1;

// LP Stage 2 para MID
m2_x1p = m2_x1; m2_x2p = m2_x2; m2_y1p = m2_y1; m2_y2p = m2_y2;
mid = lp_b0_h*mid_s1 + lp_b1_h*m2_x1p + lp_b2_h*m2_x2p - lp_a1_h*m2_y1p - lp_a2_h*m2_y2p;
m2_x2 = m2_x1p; m2_x1 = mid_s1; m2_y2 = m2_y1p; m2_y1 = mid;

// HP Stage 1 para HIGH
u1_x1p = u1_x1; u1_x2p = u1_x2; u1_y1p = u1_y1; u1_y2p = u1_y2;
high_s1 = hp_b0_h*rest + hp_b1_h*u1_x1p + hp_b2_h*u1_x2p - hp_a1_h*u1_y1p - hp_a2_h*u1_y2p;
u1_x2 = u1_x1p; u1_x1 = rest; u1_y2 = u1_y1p; u1_y1 = high_s1;

// HP Stage 2 para HIGH
u2_x1p = u2_x1; u2_x2p = u2_x2; u2_y1p = u2_y1; u2_y2p = u2_y2;
high = hp_b0_h*high_s1 + hp_b1_h*u2_x1p + hp_b2_h*u2_x2p - hp_a1_h*u2_y1p - hp_a2_h*u2_y2p;
u2_x2 = u2_x1p; u2_x1 = high_s1; u2_y2 = u2_y1p; u2_y1 = high;

// ===== SALIDAS =====
sum3 = low + mid + high;

out1 = low;   // Graves compensados
out2 = mid;   // Medios
out3 = high;  // Agudos